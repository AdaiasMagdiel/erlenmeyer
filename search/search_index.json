{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Erlenmeyer Framework","text":"<p>\u2697\ufe0f A lightweight, modular, and elegant PHP microframework for building modern web applications and APIs.</p>"},{"location":"#what-is-erlenmeyer","title":"\ud83e\udde0 What is Erlenmeyer?","text":"<p>Erlenmeyer is a minimal and composable PHP microframework that gives you the essential tools \u2014 routing, requests, responses, sessions, and testing \u2014 all without imposing any rigid structure.</p> <p>You decide how your project looks. Want a clean MVC layout? Perfect. Prefer everything in a single <code>index.php</code> file? That works too.</p> <p>It draws inspiration from the Flask microframework in Python \u2014 sharing the same principles of simplicity, explicitness, and developer freedom \u2014 but redesigned from the ground up for the PHP ecosystem.</p> <p>Erlenmeyer is about clarity without constraints.</p> <p>!!! quote \"The philosophy\" &gt; \u201cSimplicity is the ultimate sophistication.\u201d</p> <p>\u2014 Leonardo da Vinci</p>"},{"location":"#key-features","title":"\u2728 Key Features","text":"Category Highlights Routing Simple syntax with dynamic parameters (<code>/users/[id]</code>) and redirects Middleware Global and per-route, easy <code>$next($req, $res, $params)</code> chaining Requests &amp; Responses Typed API with helpers for HTML, JSON, text, and files Logging Console or rotating file-based logs with structured levels Error Handling Custom exception mapping and fallback handlers Assets Static file delivery with MIME detection and caching Sessions Flash messages and persistent data management Testing <code>ErlenClient</code> to simulate full HTTP requests for testing"},{"location":"#a-quick-example","title":"\u2699\ufe0f A Quick Example","text":"<pre><code>&lt;?php\nuse AdaiasMagdiel\\Erlenmeyer\\App;\nuse AdaiasMagdiel\\Erlenmeyer\\Request;\nuse AdaiasMagdiel\\Erlenmeyer\\Response;\n\nrequire __DIR__ . '/bootstrap.php';\n\n$app = new App();\n\n$app-&gt;get('/', fn(Request $req, Response $res) =&gt;\n    $res-&gt;withHtml('&lt;h1&gt;Hello from Erlenmeyer \u2697\ufe0f&lt;/h1&gt;')\n);\n\n$app-&gt;get('/hello/[name]', fn(Request $req, Response $res, stdClass $params) =&gt;\n    $res-&gt;withText(\"Hello, {$params-&gt;name}!\")\n);\n\n$app-&gt;run();\n</code></pre> <p>Run it with:</p> <pre><code>php -S localhost:8000\n</code></pre> <p>and visit http://localhost:8000</p>"},{"location":"#typical-project-layout","title":"\ud83e\udde9 Typical Project Layout","text":"<p>Here\u2019s a recommended structure \u2014 not mandatory. Erlenmeyer doesn\u2019t enforce any directory layout or naming convention. You\u2019re free to organize your project your way.</p> <pre><code>project/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 Controllers/\n\u2502   \u2502   \u2514\u2500\u2500 HomeController.php\n\u2502   \u251c\u2500\u2500 Models/\n\u2502   \u2502   \u2514\u2500\u2500 User.php\n\u2502   \u251c\u2500\u2500 Services/\n\u2502   \u2502   \u2514\u2500\u2500 AuthService.php\n\u2502   \u251c\u2500\u2500 Helpers/\n\u2502   \u2502   \u2514\u2500\u2500 functions.php\n\u2502   \u2514\u2500\u2500 Config/\n\u2502       \u2514\u2500\u2500 database.php\n\u2502\n\u251c\u2500\u2500 public/\n\u2502   \u251c\u2500\u2500 index.php        # Main entry point (routes)\n\u2502   \u2514\u2500\u2500 assets/\n\u2502       \u251c\u2500\u2500 css/\n\u2502       \u2514\u2500\u2500 js/\n\u2502\n\u251c\u2500\u2500 bootstrap.php        # Loads autoload, dotenv, etc.\n\u251c\u2500\u2500 composer.json\n\u251c\u2500\u2500 .env.example\n\u251c\u2500\u2500 .htaccess\n\u2514\u2500\u2500 logs/\n    \u2514\u2500\u2500 info.log\n</code></pre> <p>Freedom first</p> <p>This is just a suggestion \u2014 not a rule. You can start small with a single <code>index.php</code>, and only introduce structure as your project grows.</p>"},{"location":"#the-htaccess-recommended","title":"\ud83d\udd27 The <code>.htaccess</code> (recommended)","text":"<pre><code>RewriteEngine On\n\n# General settings\nOptions -Indexes\nOptions +FollowSymLinks\n\n# Disable Apache version exposure\nHeader always unset X-Powered-By\n\n# Allow access to static files\nRewriteRule ^(assets|public)/.* - [L]\n\n# Block direct access to PHP files except index.php\nRewriteCond %{REQUEST_URI} !/index\\.php$ [NC]\nRewriteCond %{REQUEST_URI} \\.php$ [NC]\nRewriteRule ^ - [R=404,L]\n\n# Redirect all other requests to index.php\nRewriteRule ^ index.php [L]\n</code></pre> <p>\u2705 This version improves security and readability. (Explicit <code>+FollowSymLinks</code> and clear file-access rules.)</p>"},{"location":"#next-steps","title":"\ud83d\ude80 Next Steps","text":"<ul> <li> Getting Started \u2014 install, bootstrap, and run your first route</li> <li> Routing \u2014 define endpoints with parameters and middleware</li> <li> Core Classes \u2014 deep dive into App, Request, Response, and Session APIs</li> </ul>"},{"location":"#built-by-a-developer-for-developers","title":"\u2764\ufe0f Built by a Developer, for Developers","text":"<p>Erlenmeyer was crafted by Ada\u00edas Magdiel to bring back the joy of writing clean, expressive PHP \u2014 without the weight of a framework.</p> <p>Because true elegance is having everything you need, and nothing you don\u2019t.</p>"},{"location":"#license","title":"\u2696\ufe0f License","text":"<p>Erlenmeyer is open-source software licensed under the GNU General Public License v3.0 (GPLv3).</p> <p>You are free to use, modify, and distribute it \u2014 as long as derivative works remain open and share the same freedom.</p>"},{"location":"getting-started/","title":"Getting Started","text":"<p>\u2697\ufe0f Build modern PHP apps with simplicity \u2014 the Erlenmeyer way.</p>"},{"location":"getting-started/#introduction","title":"\ud83e\udde0 Introduction","text":"<p>Erlenmeyer is designed to make web development simple, explicit, and unopinionated. There are no fixed structures, no hidden magic, and no dependency hell \u2014 just clear, expressive PHP.</p> <p>You can start small with a single <code>index.php</code> file or gradually organize your project as it grows.</p> <p>If you\u2019ve used Flask in Python, you\u2019ll feel right at home here.</p>"},{"location":"getting-started/#installation","title":"\ud83d\udce6 Installation","text":"<p>You can install Erlenmeyer through Composer \u2014 the standard PHP package manager:</p> <pre><code>composer require adaiasmagdiel/erlenmeyer\n</code></pre> <p>That\u2019s it. No scaffolding, no setup scripts \u2014 just import and start coding.</p>"},{"location":"getting-started/#project-setup-optional","title":"\ud83e\uddf1 Project Setup (Optional)","text":"<p>Erlenmeyer doesn\u2019t enforce any specific layout. You\u2019re free to organize your app however you want.</p> <p>A simple yet clean setup might look like this:</p> <pre><code>project/\n\u251c\u2500\u2500 app/\n\u2502   \u251c\u2500\u2500 Controllers/\n\u2502   \u251c\u2500\u2500 Models/\n\u2502   \u251c\u2500\u2500 Services/\n\u2502   \u2514\u2500\u2500 Helpers/\n\u251c\u2500\u2500 public/\n\u2502   \u251c\u2500\u2500 index.php\n\u2502   \u2514\u2500\u2500 assets/\n\u2502       \u251c\u2500\u2500 css/\n\u2502       \u2514\u2500\u2500 js/\n\u251c\u2500\u2500 bootstrap.php\n\u251c\u2500\u2500 composer.json\n\u251c\u2500\u2500 .htaccess\n\u2514\u2500\u2500 logs/\n</code></pre> <p>Freedom first</p> <p>You can skip all of this and start with a single <code>index.php</code>.</p> <pre><code>Erlenmeyer will run just fine.\n</code></pre>"},{"location":"getting-started/#bootstrap-file","title":"\u2699\ufe0f Bootstrap File","text":"<p>Your <code>bootstrap.php</code> typically loads the autoloader, environment variables, and initializes anything your app needs.</p> <pre><code>&lt;?php\n// bootstrap.php\n\nrequire __DIR__ . '/vendor/autoload.php';\n\nuse Dotenv\\Dotenv;\n\n// Load environment variables (optional)\nif (file_exists(__DIR__ . '/.env')) {\n    Dotenv::createImmutable(__DIR__)-&gt;load();\n}\n\n// You can also configure logs, sessions, or constants here\n</code></pre>"},{"location":"getting-started/#defining-routes","title":"\ud83e\udded Defining Routes","text":"<p>Let\u2019s create a basic web app in <code>public/index.php</code>:</p> <pre><code>&lt;?php\nuse AdaiasMagdiel\\Erlenmeyer\\App;\nuse AdaiasMagdiel\\Erlenmeyer\\Request;\nuse AdaiasMagdiel\\Erlenmeyer\\Response;\n\nrequire __DIR__ . '/../bootstrap.php';\n\n$app = new App();\n\n// Root route\n$app-&gt;get('/', fn(Request $req, Response $res) =&gt;\n    $res-&gt;withHtml('&lt;h1&gt;Hello from Erlenmeyer \u2697\ufe0f&lt;/h1&gt;')\n);\n\n// Dynamic route with parameter\n$app-&gt;get('/hello/[name]', fn(Request $req, Response $res, stdClass $params) =&gt;\n    $res-&gt;withText(\"Hello, {$params-&gt;name}!\")\n);\n\n$app-&gt;run();\n</code></pre> <p>Visit <code>http://localhost:8000</code> and enjoy your first Erlenmeyer app!</p>"},{"location":"getting-started/#adding-middleware","title":"\ud83e\udde9 Adding Middleware","text":"<p>Middlewares let you run code before or after your routes \u2014 for authentication, logging, headers, or anything else.</p> <p>They receive <code>$req</code>, <code>$res</code>, <code>$next</code>, and <code>$params</code>. Here\u2019s a simple example:</p> <pre><code>&lt;?php\n$auth = function ($req, $res, $next, $params) {\n    $token = $req-&gt;getQueryParam('token');\n\n    if ($token !== 'secret') {\n        $res-&gt;withText('Unauthorized')\n            -&gt;setStatusCode(401)\n            -&gt;send();\n        return;\n    }\n\n    // Continue to the next middleware or route\n    $next($req, $res, $params);\n};\n\n// Apply middleware globally\n$app-&gt;addMiddleware($auth);\n\n// Or per route\n$app-&gt;get('/private', fn($req, $res) =&gt;\n    $res-&gt;withHtml('&lt;h1&gt;Welcome to the secret area \ud83e\uddea&lt;/h1&gt;'),\n    [$auth]\n);\n</code></pre> <p>Flexible design</p> <p>Middlewares can modify the request, response, or even stop the flow \u2014</p> <pre><code>just like in Flask or Express.js, but with pure PHP.\n</code></pre>"},{"location":"getting-started/#running-the-app","title":"\ud83e\uddf0 Running the App","text":"<p>You can use PHP\u2019s built-in server to start immediately:</p> <pre><code>php -S localhost:8000 -t public\n</code></pre> <p>Then open http://localhost:8000 in your browser.</p>"},{"location":"getting-started/#serving-static-files-optional","title":"\ud83e\udde9 Serving Static Files (Optional)","text":"<p>If you use the <code>Assets</code> class, Erlenmeyer can automatically handle static files.</p> <p>Example:</p> <pre><code>use AdaiasMagdiel\\Erlenmeyer\\App;\nuse AdaiasMagdiel\\Erlenmeyer\\Assets;\n\n$assets = new Assets(__DIR__ . '/assets', '/assets');\n$app = new App($assets);\n</code></pre> <p>This setup serves files from <code>/assets/</code> (or <code>/public/assets/</code>), with MIME type detection, caching, and 304 responses built-in.</p>"},{"location":"getting-started/#recommended-htaccess","title":"\ud83d\udd27 Recommended <code>.htaccess</code>","text":"<p>If you\u2019re hosting on Apache, use this file to route all requests to <code>index.php</code>:</p> <pre><code>RewriteEngine On\n\n# General settings\nOptions -Indexes\nOptions +FollowSymLinks\n\n# Disable Apache version exposure\nHeader always unset X-Powered-By\n\n# Allow access to static files\nRewriteRule ^(assets|public)/.* - [L]\n\n# Block direct access to PHP files except index.php\nRewriteCond %{REQUEST_URI} !/index\\.php$ [NC]\nRewriteCond %{REQUEST_URI} \\.php$ [NC]\nRewriteRule ^ - [R=404,L]\n\n# Redirect all other requests to index.php\nRewriteRule ^ index.php [L]\n</code></pre>"},{"location":"getting-started/#whats-next","title":"\ud83d\ude80 What\u2019s Next","text":"<ul> <li> Concepts \u2192 Routing \u2014 how routes, parameters, and middleware work</li> <li> Reference \u2192 App \u2014 deep dive into the <code>App</code> class</li> <li> Assets \u2014 serving static files and media</li> </ul>"},{"location":"getting-started/#license","title":"\u2696\ufe0f License","text":"<p>Erlenmeyer is open-source software licensed under the GNU General Public License v3.0 (GPLv3).</p> <p>You are free to use, modify, and distribute it \u2014 as long as derivative works remain open and share the same freedom.</p>"},{"location":"advanced/custom-handlers/","title":"Advanced: Custom Handlers","text":"<p>Erlenmeyer allows you to fully customize logging and exception handling behavior. This includes:</p> <ul> <li>Creating custom loggers by implementing <code>LoggerInterface</code>;</li> <li>Registering custom exception handlers using <code>App::setExceptionHandler()</code>.</li> </ul> <p>These features are useful when integrating Erlenmeyer with external systems (such as Sentry, Logstash, or Graylog), or when defining precise responses for specific error types.</p>"},{"location":"advanced/custom-handlers/#1-creating-a-custom-logger","title":"1. Creating a Custom Logger","text":"<p>All loggers in Erlenmeyer implement the <code>LoggerInterface</code>:</p> <pre><code>interface LoggerInterface\n{\n    public function log(LogLevel $level, string $message): void;\n    public function logException(Exception $e, ?Request $request = null): void;\n}\n</code></pre> <p>To create your own logger, simply implement this interface.</p>"},{"location":"advanced/custom-handlers/#example-json-based-logger","title":"Example: JSON-based Logger","text":"<pre><code>use AdaiasMagdiel\\Erlenmeyer\\Logging\\LoggerInterface;\nuse AdaiasMagdiel\\Erlenmeyer\\Logging\\LogLevel;\nuse AdaiasMagdiel\\Erlenmeyer\\Request;\nuse Exception;\n\nclass JsonLogger implements LoggerInterface\n{\n    private string $file;\n\n    public function __construct(string $file = __DIR__ . '/app.log')\n    {\n        $this-&gt;file = $file;\n    }\n\n    public function log(LogLevel $level, string $message): void\n    {\n        $entry = [\n            'timestamp' =&gt; date('c'),\n            'level' =&gt; $level-&gt;value,\n            'message' =&gt; $message\n        ];\n\n        file_put_contents($this-&gt;file, json_encode($entry) . PHP_EOL, FILE_APPEND);\n    }\n\n    public function logException(Exception $e, ?Request $request = null): void\n    {\n        $entry = [\n            'timestamp' =&gt; date('c'),\n            'level' =&gt; LogLevel::ERROR-&gt;value,\n            'message' =&gt; $e-&gt;getMessage(),\n            'file' =&gt; $e-&gt;getFile(),\n            'line' =&gt; $e-&gt;getLine(),\n            'trace' =&gt; explode(\"\\n\", $e-&gt;getTraceAsString()),\n            'request' =&gt; $request ? [\n                'method' =&gt; $request-&gt;getMethod(),\n                'uri' =&gt; $request-&gt;getUri(),\n            ] : null,\n        ];\n\n        file_put_contents($this-&gt;file, json_encode($entry) . PHP_EOL, FILE_APPEND);\n    }\n}\n</code></pre> <p>Then inject it into your app:</p> <pre><code>use AdaiasMagdiel\\Erlenmeyer\\App;\n\n$app = new App(null, new JsonLogger(__DIR__ . '/logs/app.jsonl'));\n</code></pre> <p>Each log entry is stored as a separate JSON line \u2014 ideal for structured logging and observability tools.</p>"},{"location":"advanced/custom-handlers/#2-registering-custom-exception-handlers","title":"2. Registering Custom Exception Handlers","text":"<p>The method <code>setExceptionHandler()</code> lets you define specific behaviors for particular exception types.</p> <pre><code>$app-&gt;setExceptionHandler(TypeError::class, function ($req, $res, $e) {\n    $res-&gt;setStatusCode(400)\n        -&gt;withJson([\n            'error' =&gt; 'Invalid type',\n            'message' =&gt; $e-&gt;getMessage(),\n        ])\n        -&gt;send();\n});\n</code></pre> <p>You can also handle your own custom exception classes:</p> <pre><code>class ValidationException extends Exception {}\n\n$app-&gt;setExceptionHandler(ValidationException::class, function ($req, $res, $e) {\n    $res-&gt;setStatusCode(422)\n        -&gt;withJson(['error' =&gt; $e-&gt;getMessage()])\n        -&gt;send();\n});\n</code></pre> <p>When an exception is thrown, Erlenmeyer traverses the exception\u2019s class hierarchy to find the most specific registered handler, falling back to the generic <code>Throwable</code> handler if none matches.</p>"},{"location":"advanced/custom-handlers/#3-global-fallback-exception-handler","title":"3. Global (Fallback) Exception Handler","text":"<p>By default, Erlenmeyer defines a generic 500 handler:</p> <pre><code>$app-&gt;setExceptionHandler(Throwable::class, function ($req, $res, $e) {\n    $res-&gt;setStatusCode(500)\n        -&gt;withHtml(\"&lt;h1&gt;500 Internal Server Error&lt;/h1&gt;&lt;p&gt;Error: {$e-&gt;getMessage()}&lt;/p&gt;\")\n        -&gt;send();\n});\n</code></pre> <p>You can override it to return a consistent JSON response instead:</p> <pre><code>$app-&gt;setExceptionHandler(Throwable::class, function ($req, $res, $e) {\n    $res-&gt;setStatusCode(500)\n        -&gt;withJson([\n            'status' =&gt; 'error',\n            'message' =&gt; $e-&gt;getMessage(),\n        ])\n        -&gt;send();\n});\n</code></pre>"},{"location":"advanced/custom-handlers/#4-combining-loggers-and-handlers","title":"4. Combining Loggers and Handlers","text":"<p>It\u2019s common to use a logger inside a custom exception handler for better traceability:</p> <pre><code>use AdaiasMagdiel\\Erlenmeyer\\Logging\\LogLevel;\n\n$app-&gt;setExceptionHandler(RuntimeException::class, function ($req, $res, $e) use ($app) {\n    // Log details\n    $logger = new JsonLogger(__DIR__ . '/logs/errors.jsonl');\n    $logger-&gt;logException($e, $req);\n\n    // Send friendly response\n    $res-&gt;setStatusCode(500)\n        -&gt;withJson(['error' =&gt; 'Unexpected server error'])\n        -&gt;send();\n});\n</code></pre>"},{"location":"advanced/custom-handlers/#5-full-example","title":"5. Full Example","text":"<pre><code>use AdaiasMagdiel\\Erlenmeyer\\App;\nuse AdaiasMagdiel\\Erlenmeyer\\Logging\\FileLogger;\n\nrequire 'vendor/autoload.php';\n\n$logger = new FileLogger(__DIR__ . '/logs');\n$app = new App(null, $logger);\n\n// Handler for validation exceptions\n$app-&gt;setExceptionHandler(ValidationException::class, function ($req, $res, $e) use ($logger) {\n    $logger-&gt;logException($e, $req);\n    $res-&gt;setStatusCode(422)-&gt;withJson(['error' =&gt; $e-&gt;getMessage()])-&gt;send();\n});\n\n// Global fallback handler\n$app-&gt;setExceptionHandler(Throwable::class, function ($req, $res, $e) use ($logger) {\n    $logger-&gt;logException($e, $req);\n    $res-&gt;setStatusCode(500)-&gt;withText('Internal Server Error')-&gt;send();\n});\n\n$app-&gt;get('/test', function ($req, $res) {\n    throw new ValidationException('Invalid input data');\n});\n\n$app-&gt;run();\n</code></pre>"},{"location":"advanced/custom-handlers/#6-best-practices","title":"6. Best Practices","text":"<p>\u2705 Catch specific exception types first (e.g. <code>ValidationException</code>, <code>TypeError</code>). \u2705 Use loggers for technical detail, and handlers for user-facing messages. \u2705 Avoid exposing sensitive data in production error responses. \u2705 Combine with global middlewares to normalize errors consistently.</p>"},{"location":"advanced/custom-handlers/#summary","title":"Summary","text":"Feature Purpose LoggerInterface Defines the common logging contract FileLogger / ConsoleLogger Default logger implementations setExceptionHandler() Associates exception types with custom responses Custom Logger Integrate with external tools (Sentry, Logstash, etc.) <p>With these tools, you can build professional-grade error handling and observability pipelines inside Erlenmeyer.</p> <p>Next: \ud83d\udcd8 Testing with ErlenClient \u2192</p>"},{"location":"advanced/logging/","title":"Advanced: Logging","text":"<p>Erlenmeyer includes a flexible logging system designed for both file-based and console-based environments. It provides standardized severity levels and supports context-aware exception logging, including request details and stack traces.</p>"},{"location":"advanced/logging/#overview","title":"Overview","text":"<p>Logging in Erlenmeyer is powered by the <code>LoggerInterface</code>, which defines two main methods:</p> <pre><code>public function log(LogLevel $level, string $message): void;\npublic function logException(Exception $e, ?Request $request = null): void;\n</code></pre> <p>Two implementations are included by default:</p> Class Description <code>FileLogger</code> Writes structured log entries to disk, with automatic rotation. <code>ConsoleLogger</code> Writes log entries to the PHP error log or STDERR (useful in CLI/testing). <p>You can also create custom loggers by implementing <code>LoggerInterface</code> \u2014 covered in the Custom Handlers section.</p>"},{"location":"advanced/logging/#log-levels","title":"Log Levels","text":"<p>Erlenmeyer defines standard log severity levels using the <code>LogLevel</code> enum:</p> <pre><code>enum LogLevel: string {\n    case DEBUG = 'DEBUG';\n    case INFO = 'INFO';\n    case WARNING = 'WARNING';\n    case ERROR = 'ERROR';\n    case CRITICAL = 'CRITICAL';\n}\n</code></pre> <p>All loggers support these levels consistently.</p>"},{"location":"advanced/logging/#1-filelogger","title":"1. FileLogger","text":""},{"location":"advanced/logging/#basic-setup","title":"Basic Setup","text":"<p>The <code>FileLogger</code> stores logs in a directory of your choice and automatically rotates log files when they reach 3MB.</p> <pre><code>use AdaiasMagdiel\\Erlenmeyer\\Logging\\FileLogger;\nuse AdaiasMagdiel\\Erlenmeyer\\App;\n\n$logger = new FileLogger(__DIR__ . '/logs');\n$app = new App(null, $logger);\n</code></pre> <ul> <li>Logs are stored in <code>info.log</code> inside the specified directory.</li> <li>When <code>info.log</code> exceeds 3MB, it is renamed to <code>info.log.1</code>, and older logs are shifted up to <code>info.log.5</code>.</li> </ul>"},{"location":"advanced/logging/#example-log-entry","title":"Example Log Entry","text":"<pre><code>[2025-10-15 14:03:21] [INFO] Route registered: GET /users\n</code></pre>"},{"location":"advanced/logging/#exception-logging","title":"Exception Logging","text":"<p>Exceptions are logged with full context, including the request method, URI, and stack trace:</p> <pre><code>[2025-10-15 14:05:11] [ERROR] Invalid argument in /app/UserController.php:84\nRequest: POST /users\n#0 /app/App.php(210): ...\n</code></pre>"},{"location":"advanced/logging/#2-consolelogger","title":"2. ConsoleLogger","text":"<p>The <code>ConsoleLogger</code> writes directly to PHP\u2019s error log or <code>STDERR</code>. This is ideal for development, testing, or containerized deployments.</p> <pre><code>use AdaiasMagdiel\\Erlenmeyer\\Logging\\ConsoleLogger;\n\n$logger = new ConsoleLogger();\n$app = new App(null, $logger);\n</code></pre> <p>You can also exclude specific levels to reduce verbosity:</p> <pre><code>use AdaiasMagdiel\\Erlenmeyer\\Logging\\LogLevel;\n\n$logger = new ConsoleLogger([LogLevel::DEBUG, LogLevel::INFO]);\n</code></pre> <p>Now only warnings, errors, and critical messages will appear in your logs.</p>"},{"location":"advanced/logging/#3-custom-logger-injection","title":"3. Custom Logger Injection","text":"<p>Any logger implementing <code>LoggerInterface</code> can be injected into the application.</p> <pre><code>use AdaiasMagdiel\\Erlenmeyer\\App;\nuse MyApp\\CustomLogger;\n\n$logger = new CustomLogger();\n$app = new App(null, $logger);\n</code></pre> <p>The logger is used internally by the <code>App</code> to record:</p> <ul> <li>Route registration and middleware execution</li> <li>404 and 500 errors</li> <li>Unhandled exceptions</li> <li>Asset serving and redirect handling</li> </ul>"},{"location":"advanced/logging/#4-handling-exceptions-manually","title":"4. Handling Exceptions Manually","text":"<p>You can also log exceptions directly in your route handlers or middlewares:</p> <pre><code>use AdaiasMagdiel\\Erlenmeyer\\Logging\\LogLevel;\n\n$app-&gt;get('/users', function ($req, $res) use ($app) {\n    try {\n        // ...\n    } catch (Exception $e) {\n        $appLogger = new FileLogger(__DIR__ . '/logs');\n        $appLogger-&gt;logException($e, $req);\n        $res-&gt;setStatusCode(500)-&gt;withText('An internal error occurred');\n    }\n});\n</code></pre>"},{"location":"advanced/logging/#5-when-logging-is-disabled","title":"5. When Logging is Disabled","text":"<p>If you initialize <code>FileLogger</code> without a directory path:</p> <pre><code>$logger = new FileLogger('');\n</code></pre> <p>Logging is silently disabled \u2014 no files are created, and all log calls become no-ops.</p> <p>This can be useful for production builds where logs are handled by external systems.</p>"},{"location":"advanced/logging/#summary","title":"Summary","text":"Logger Output Rotation Contextual Exceptions Recommended For FileLogger Files (<code>info.log</code>) \u2705 Yes \u2705 Yes Production ConsoleLogger <code>error_log()</code> / STDERR \u274c No \u2705 Yes Development / CI Custom Logger User-defined Optional Optional Advanced setups <p>Next: \ud83d\udcd8 Custom Handlers \u2192</p>"},{"location":"concepts/assets/","title":"Serving Static Assets","text":"<p>Erlenmeyer includes a lightweight, built-in system for serving static files \u2014 such as images, CSS, JavaScript, or other public resources \u2014 through the <code>Assets</code> class.</p> <p>It\u2019s fully optional, but extremely convenient for small or self-contained projects.</p>"},{"location":"concepts/assets/#overview","title":"\ud83e\udde9 Overview","text":"<p>When you provide an <code>Assets</code> instance to your <code>App</code>, Erlenmeyer automatically:</p> <ul> <li>Detects static requests (e.g., <code>/assets/style.css</code>)</li> <li>Resolves the correct file path safely</li> <li>Sends the file with proper MIME type, cache headers, and ETag support</li> <li>Returns <code>304 Not Modified</code> when the client already has a cached copy</li> </ul> <p>If the requested file doesn\u2019t exist, the 404 handler is triggered.</p>"},{"location":"concepts/assets/#basic-setup","title":"\u2699\ufe0f Basic Setup","text":"<p>To enable asset serving, create an <code>Assets</code> instance and pass it to the <code>App</code> constructor:</p> <pre><code>use AdaiasMagdiel\\Erlenmeyer\\App;\nuse AdaiasMagdiel\\Erlenmeyer\\Assets;\n\n$assets = new Assets(__DIR__ . '/assets', '/assets');\n$app = new App($assets);\n</code></pre> <p>Now any request to <code>/assets/...</code> will automatically serve files from the <code>/assets</code> folder in your project.</p> <p>Example:</p> <pre><code>/assets/style.css  \u2192  ./assets/style.css\n/assets/logo.png   \u2192  ./assets/logo.png\n</code></pre>"},{"location":"concepts/assets/#typical-directory-structure","title":"\ud83d\udcc1 Typical Directory Structure","text":"<pre><code>project/\n\u251c\u2500\u2500 public/\n\u2502   \u251c\u2500\u2500 index.php\n\u2502   \u2514\u2500\u2500 assets/\n\u2502       \u251c\u2500\u2500 css/\n\u2502       \u2502   \u2514\u2500\u2500 style.css\n\u2502       \u251c\u2500\u2500 js/\n\u2502       \u2502   \u2514\u2500\u2500 app.js\n\u2502       \u2514\u2500\u2500 images/\n\u2502           \u2514\u2500\u2500 logo.png\n</code></pre> <p>In this setup, your entry point (<code>index.php</code>) might look like this:</p> <pre><code>$assets = new Assets(__DIR__ . '/assets', '/assets');\n$app = new App($assets);\n</code></pre> <p>And then run with:</p> <pre><code>php -S localhost:8000 -t public\n</code></pre> <p>Now visiting <code>http://localhost:8000/assets/css/style.css</code> will deliver the file automatically.</p>"},{"location":"concepts/assets/#how-it-works","title":"\ud83e\udde0 How It Works","text":"<p>When the <code>Assets</code> manager is active:</p> <ol> <li>Erlenmeyer checks if the current request matches the assets route prefix (e.g., <code>/assets</code>).</li> <li>It resolves the requested path safely inside the configured directory.</li> <li> <p>It sets standard headers for performance and caching:</p> </li> <li> <p><code>Content-Type</code></p> </li> <li><code>Content-Length</code></li> <li><code>Cache-Control</code></li> <li><code>ETag</code></li> <li> <p><code>Last-Modified</code></p> </li> <li> <p>If the client already has the file cached (<code>If-None-Match</code> or <code>If-Modified-Since</code>),    a 304 Not Modified response is sent instead of retransmitting the file.</p> </li> </ol> <p>This happens before the 404 handler or any route logic \u2014 so you don\u2019t need to define routes for assets manually.</p>"},{"location":"concepts/assets/#security","title":"\ud83d\udd12 Security","text":"<p>The <code>Assets</code> class uses strict path validation to prevent directory traversal. It ensures all served files reside inside the configured directory.</p> <p>If a user tries to request something outside (like <code>../../config.php</code>), the request is rejected with a 404.</p>"},{"location":"concepts/assets/#custom-asset-route","title":"\ud83e\udde9 Custom Asset Route","text":"<p>You can change the public route prefix. For example, to serve files under <code>/static/</code> instead of <code>/assets/</code>:</p> <pre><code>$assets = new Assets(__DIR__ . '/assets', '/static');\n$app = new App($assets);\n</code></pre> <p>Now <code>/static/logo.png</code> will map to <code>./assets/logo.png</code>.</p>"},{"location":"concepts/assets/#mime-detection","title":"\ud83e\uddf0 MIME Detection","text":"<p>Erlenmeyer automatically determines the MIME type of the file based on its extension.</p> File Type MIME Type <code>.css</code> <code>text/css</code> <code>.js</code> <code>application/javascript</code> <code>.png</code>, <code>.jpg</code>, <code>.svg</code> Appropriate image MIME <code>.json</code>, <code>.xml</code>, <code>.pdf</code>, <code>.zip</code>, etc. Fully supported <p>All common web file types are included \u2014 you rarely need to configure anything manually.</p>"},{"location":"concepts/assets/#conditional-requests-caching","title":"\u2699\ufe0f Conditional Requests &amp; Caching","text":"<p>When possible, Erlenmeyer responds with:</p> <ul> <li><code>ETag</code> and <code>Last-Modified</code> headers for cache validation</li> <li><code>Cache-Control: public, max-age=86400</code> (1 day)</li> <li><code>304 Not Modified</code> when the resource hasn\u2019t changed</li> </ul> <p>This makes your app efficient even without a CDN.</p>"},{"location":"concepts/assets/#example-manual-asset-check","title":"\ud83e\uddf1 Example: Manual Asset Check","text":"<p>You can check or serve an asset manually if needed:</p> <pre><code>use AdaiasMagdiel\\Erlenmeyer\\Request;\n\n$req = new Request();\nif ($assets-&gt;isAssetRequest($req)) {\n    $assets-&gt;serveAsset($req);\n}\n</code></pre> <p>Normally, you don\u2019t need to call this \u2014 the framework does it automatically when no route matches.</p>"},{"location":"concepts/assets/#error-handling","title":"\ud83e\udde9 Error Handling","text":"<p>If an asset cannot be found or accessed:</p> <ul> <li>The HTTP status code is set to 404</li> <li>The message <code>File not found</code> is sent</li> <li>The logger records the failed attempt (if logging is enabled)</li> </ul>"},{"location":"concepts/assets/#summary","title":"\ud83d\ude80 Summary","text":"Concept Description Assets class Handles static file serving Automatic detection Requests under the assets route are auto-served Safe paths Prevents directory traversal attacks MIME types Automatically determined per file Caching Supports ETag, Last-Modified, and 304 responses Configurable route <code>/assets</code> by default, customizable via constructor <p>Use it only when you need it</p> <p>In production setups (especially behind Nginx or Apache), it\u2019s best to let the web server handle static files directly. The built-in <code>Assets</code> class is ideal for local development, testing, or self-contained PHP deployments.</p>"},{"location":"concepts/errors/","title":"Error Handling","text":"<p>Erlenmeyer provides a simple yet powerful mechanism for handling errors and exceptions \u2014 from route-level issues to application-wide exception mapping.</p> <p>You can define custom exception handlers, global fallbacks, and graceful 404 pages, all while keeping things clear and explicit.</p>"},{"location":"concepts/errors/#default-behavior","title":"\ud83e\udde9 Default Behavior","text":"<p>By default, Erlenmeyer catches all uncaught exceptions and displays a simple HTML error page:</p> <pre><code>&lt;h1&gt;500 Internal Server Error&lt;/h1&gt;\n&lt;p&gt;Error: [message]&lt;/p&gt;\n</code></pre> <p>It also logs every exception to the configured logger.</p> <p>If no route matches the request, the framework automatically runs the 404 handler \u2014 which is also customizable.</p>"},{"location":"concepts/errors/#custom-404-handler","title":"\u2699\ufe0f Custom 404 Handler","text":"<p>You can override the default 404 handler using <code>set404Handler()</code>:</p> <pre><code>$app-&gt;set404Handler(function (Request $req, Response $res) {\n    $res-&gt;setStatusCode(404)\n        -&gt;withHtml('&lt;h1&gt;Oops! Page not found \ud83d\ude15&lt;/h1&gt;')\n        -&gt;send();\n});\n</code></pre> <p>This handler is called when no route matches and no static asset is served.</p> <p>You can include route info, headers, or even return JSON for API responses.</p> <pre><code>$app-&gt;set404Handler(fn($req, $res) =&gt;\n    $res-&gt;withJson([\n        'error' =&gt; 'Resource not found',\n        'path' =&gt; $req-&gt;getUri()\n    ])-&gt;setStatusCode(404)-&gt;send()\n);\n</code></pre>"},{"location":"concepts/errors/#exception-handling","title":"\ud83e\uddf1 Exception Handling","text":"<p>Erlenmeyer lets you map specific exception classes to custom handlers using <code>setExceptionHandler($class, $callable)</code>.</p> <p>Each handler receives the current <code>Request</code>, <code>Response</code>, and the thrown exception instance.</p> <p>Example:</p> <pre><code>use RuntimeException;\nuse TypeError;\n\n$app-&gt;setExceptionHandler(RuntimeException::class, function ($req, $res, $e) {\n    $res-&gt;withJson([\n        'error' =&gt; 'Runtime error',\n        'message' =&gt; $e-&gt;getMessage(),\n    ])-&gt;setStatusCode(500)-&gt;send();\n});\n\n$app-&gt;setExceptionHandler(TypeError::class, function ($req, $res, $e) {\n    $res-&gt;withText(\"Invalid type: {$e-&gt;getMessage()}\")\n        -&gt;setStatusCode(400)\n        -&gt;send();\n});\n</code></pre> <p>If an exception doesn\u2019t match any registered class, Erlenmeyer falls back to the generic <code>Throwable</code> handler (the default 500 page).</p>"},{"location":"concepts/errors/#built-in-logging","title":"\ud83e\udea4 Built-in Logging","text":"<p>Every caught exception is automatically logged through the configured logger.</p> <p>By default:</p> <ul> <li>Errors go to <code>logs/info.log</code> via <code>FileLogger</code>.</li> <li>Each log includes the timestamp, exception type, message, file, and line number.</li> <li>Request context (method + URI) is included when available.</li> </ul> <p>Example log entry:</p> <pre><code>[2025-10-15 12:34:56] [ERROR] Undefined variable in /app/Controllers/Home.php:42\nRequest: GET /home\nStack trace:\n  #0 /public/index.php(10): HomeController-&gt;index()\n  ...\n</code></pre> <p>You can plug in your own logger (e.g., Monolog or a custom PSR-3 implementation) by passing it to the <code>App</code> constructor:</p> <pre><code>$logger = new MyCustomLogger();\n$app = new App(null, $logger);\n</code></pre>"},{"location":"concepts/errors/#handling-php-errors","title":"\ud83e\uddf0 Handling PHP Errors","text":"<p>Erlenmeyer automatically converts PHP errors (like notices or warnings) into <code>ErrorException</code> instances, which are then caught by the exception system.</p> <p>This ensures consistent error handling across your entire app.</p> <p>Example:</p> <pre><code>// Triggers an ErrorException (not a fatal PHP warning)\necho $undefinedVar;\n</code></pre> <p>\u2192 The exception is caught, logged, and rendered using your registered handlers.</p>"},{"location":"concepts/errors/#exception-resolution-order","title":"\ud83d\udd04 Exception Resolution Order","text":"<p>When an exception is thrown, Erlenmeyer searches for a handler in this order:</p> <ol> <li>Exact match (e.g., <code>TypeError</code>)</li> <li>Parent class (e.g., <code>Error</code>)</li> <li>Generic <code>Throwable</code> handler (fallback)</li> </ol> <p>This means you can safely define specific handlers first and let more general ones handle everything else.</p>"},{"location":"concepts/errors/#example-full-error-stack","title":"\ud83d\ude80 Example: Full Error Stack","text":"<pre><code>$app-&gt;setExceptionHandler(DomainException::class, fn($req, $res, $e) =&gt;\n    $res-&gt;withJson([\n        'error' =&gt; 'Domain violation',\n        'message' =&gt; $e-&gt;getMessage()\n    ])-&gt;setStatusCode(422)-&gt;send()\n);\n\n$app-&gt;setExceptionHandler(Throwable::class, fn($req, $res, $e) =&gt;\n    $res-&gt;withJson([\n        'error' =&gt; 'Unexpected server error',\n        'message' =&gt; $e-&gt;getMessage()\n    ])-&gt;setStatusCode(500)-&gt;send()\n);\n</code></pre> <p>Then, if your route throws:</p> <pre><code>throw new DomainException(\"Invalid email format\");\n</code></pre> <p>You\u2019ll get:</p> <pre><code>{\n  \"error\": \"Domain violation\",\n  \"message\": \"Invalid email format\"\n}\n</code></pre>"},{"location":"concepts/errors/#summary","title":"\ud83e\udded Summary","text":"Concept Description 404 Handler Custom response when no route matches Exception Handler Maps exception classes to custom handlers Logging All exceptions are logged automatically Error Conversion PHP warnings and notices become exceptions Fallback Default 500 handler for uncaught exceptions <p>Keep it clean</p> <p>Because handlers receive both the <code>Request</code> and <code>Response</code>, you can return HTML for web apps, JSON for APIs, or even integrate third-party logging and monitoring tools like Sentry or Bugsnag.</p>"},{"location":"concepts/middleware/","title":"Middleware","text":"<p>Middleware in Erlenmeyer provides a clean way to intercept, modify, or reject a request before it reaches your route handler \u2014 or to alter the response afterward.</p> <p>They\u2019re simple callables that receive the current <code>Request</code>, <code>Response</code>, a <code>$next</code> callback, and optional route parameters.</p>"},{"location":"concepts/middleware/#how-a-middleware-works","title":"How a middleware works","text":"<p>A middleware has the following signature:</p> <pre><code>function (Request $req, Response $res, callable $next, stdClass $params): void\n</code></pre> <p>It can:</p> <ul> <li>inspect or modify the incoming request,</li> <li>stop execution and send a response directly,</li> <li>or call <code>$next()</code> to continue the chain.</li> </ul> <p>Example:</p> <pre><code>$auth = function ($req, $res, $next, $params) {\n    $token = $req-&gt;getQueryParam('token');\n    if ($token !== 'secret') {\n        $res-&gt;withText('Unauthorized')-&gt;setStatusCode(401)-&gt;send();\n        return;\n    }\n\n    $next($req, $res, $params);\n};\n</code></pre>"},{"location":"concepts/middleware/#applying-middleware-to-a-single-route","title":"Applying middleware to a single route","text":"<p>You can attach one or more middlewares directly to a route:</p> <pre><code>$app-&gt;get('/dashboard', function ($req, $res) {\n    $res-&gt;withText('Welcome to your dashboard')-&gt;send();\n}, [$auth]);\n</code></pre> <p>Middlewares are executed in the order they\u2019re defined.</p>"},{"location":"concepts/middleware/#global-middlewares","title":"Global middlewares","text":"<p>If you want a middleware to run on every route, register it globally:</p> <pre><code>$app-&gt;addMiddleware($auth);\n</code></pre> <p>All routes declared afterward will automatically include it in their execution chain. You can combine global and route-specific middlewares freely.</p>"},{"location":"concepts/middleware/#stopping-the-chain","title":"Stopping the chain","text":"<p>A middleware can terminate the request early simply by not calling <code>$next()</code>. This is useful for authentication, validation, or rate-limiting:</p> <pre><code>$rateLimit = function ($req, $res, $next, $params) {\n    if (Session::get('requests') &gt; 100) {\n        $res-&gt;setStatusCode(429)-&gt;withText('Too many requests')-&gt;send();\n        return;\n    }\n    $next($req, $res, $params);\n};\n</code></pre>"},{"location":"concepts/middleware/#execution-order","title":"Execution order","text":"<p>Erlenmeyer builds the middleware chain in a way that ensures the first added middleware is the first executed.</p> <p>Internally, the framework reverses the array before wrapping each middleware, so execution happens in the same order you register them \u2014 from outside in.</p> <p>For example:</p> <pre><code>$app-&gt;addMiddleware(A);\n$app-&gt;addMiddleware(B);\n$app-&gt;addMiddleware(C);\n</code></pre> <p>The resulting execution order is:</p> <pre><code>A \u2192 B \u2192 C \u2192 Route Handler\n</code></pre> <p>Each middleware receives a <code>$next()</code> callback that continues the chain. If a middleware doesn\u2019t call <code>$next()</code>, the chain stops there.</p>"},{"location":"concepts/middleware/#route-specific-middlewares","title":"Route-specific middlewares","text":"<p>When you attach middlewares to a specific route:</p> <pre><code>$app-&gt;get('/admin', $handler, [$auth, $log]);\n</code></pre> <p>The order will be:</p> <pre><code>auth \u2192 log \u2192 Route Handler\n</code></pre>"},{"location":"concepts/middleware/#global-route-middlewares-together","title":"Global + route middlewares together","text":"<p>Global middlewares run before route-specific ones:</p> <pre><code>$app-&gt;addMiddleware($log);\n$app-&gt;get('/secure', $handler, [$auth]);\n</code></pre> <p>Execution order:</p> <pre><code>Global log \u2192 Route auth \u2192 Route Handler\n</code></pre>"},{"location":"concepts/middleware/#visual-model","title":"Visual model","text":"<pre><code>+-----------------------------+\n| Global Middleware (A)       |\n|   +-----------------------+ |\n|   | Route Middleware (B)  | |\n|   |   +-----------------+ | |\n|   |   | Handler (C)     | | |\n|   |   +-----------------+ | |\n|   +-----------------------+ |\n+-----------------------------+\n</code></pre> <p>\u2192 Executed in order: A \u2192 B \u2192 C</p>"},{"location":"concepts/middleware/#example-chaining-multiple-middlewares","title":"Example: chaining multiple middlewares","text":"<pre><code>$log = fn($req, $res, $next) =&gt; (\n    error_log(\"[LOG] {$req-&gt;getMethod()} {$req-&gt;getUri()}\"),\n    $next($req, $res, new stdClass())\n);\n\n$auth = fn($req, $res, $next) =&gt; (\n    $req-&gt;getQueryParam('token') === 'secret'\n        ? $next($req, $res, new stdClass())\n        : $res-&gt;withText('Unauthorized')-&gt;setStatusCode(401)-&gt;send()\n);\n\n$app-&gt;addMiddleware($log);\n$app-&gt;get('/admin', fn($req, $res) =&gt; $res-&gt;withText('Admin OK')-&gt;send(), [$auth]);\n</code></pre> <p>Execution flow:</p> <ol> <li><code>$log</code> runs (global)</li> <li><code>$auth</code> runs (route-specific)</li> <li>Route handler runs</li> <li>Response is sent</li> </ol>"},{"location":"concepts/middleware/#middleware-use-cases","title":"Middleware use cases","text":"<p>\u2705 Common scenarios:</p> <ul> <li>Authentication / Authorization</li> <li>Logging and metrics</li> <li>Request validation</li> <li>CORS and headers</li> <li>JSON body parsing or content negotiation</li> <li>Exception wrapping or retry mechanisms</li> </ul> <p>Because middlewares are just PHP functions, you can easily reuse or compose them across projects.</p>"},{"location":"concepts/middleware/#internals","title":"Internals","text":"<p>When you define a route, Erlenmeyer merges:</p> <ul> <li>Global middlewares (added with <code>addMiddleware()</code>)</li> <li>Route-specific ones (passed to <code>get()</code>, <code>post()</code>, etc.)</li> </ul> <p>Then it wraps them around the route\u2019s handler using <code>applyMiddlewares()</code> inside the <code>App</code> class:</p> <pre><code>private function applyMiddlewares(callable $handler, array $middlewares): callable {\n    $next = $handler;\n    $middlewares = array_reverse($middlewares);\n\n    foreach ($middlewares as $middleware) {\n        $next = function ($req, $res, $params) use ($middleware, $next) {\n            $middleware($req, $res, fn($req, $res, $p) =&gt; $next($req, $res, $p), $params);\n        };\n    }\n\n    return $next;\n}\n</code></pre> <p>This keeps everything explicit, transparent, and framework-free \u2014 just function composition.</p>"},{"location":"concepts/middleware/#in-short","title":"In short","text":"Concept Description Middleware A function that can inspect, modify, or short-circuit a request. Global middleware Applied to every route. Route middleware Applied only to specific routes. $next() Calls the next middleware or the final route handler. Freedom You can stack them however you want."},{"location":"concepts/requests/","title":"Handling Requests","text":"<p>Erlenmeyer\u2019s <code>Request</code> object gives you a clean, expressive way to interact with incoming HTTP requests \u2014 from query strings and forms to JSON payloads, uploaded files, and headers.</p>"},{"location":"concepts/requests/#accessing-the-request","title":"Accessing the Request","text":"<p>Every route in Erlenmeyer receives the request object as the first argument:</p> <pre><code>$app-&gt;get('/hello', function (Request $req, Response $res) {\n    $name = $req-&gt;getQueryParam('name', 'world');\n    $res-&gt;withText(\"Hello, {$name}!\")-&gt;send();\n});\n</code></pre> <p>Here, <code>/hello?name=Adaias</code> responds with:</p> <pre><code>Hello, Adaias!\n</code></pre> <p>And <code>/hello</code> responds with:</p> <pre><code>Hello, world!\n</code></pre>"},{"location":"concepts/requests/#reading-query-and-form-data","title":"Reading Query and Form Data","text":"<pre><code>$name = $req-&gt;getQueryParam('name');   // ?name=John\n$email = $req-&gt;getFormDataParam('email'); // POST form input\n</code></pre> <p>You can also get all parameters at once:</p> <pre><code>$req-&gt;getQueryParams(); // returns array\n$req-&gt;getFormData();    // returns array\n</code></pre>"},{"location":"concepts/requests/#working-with-json","title":"Working with JSON","text":"<p>Erlenmeyer automatically decodes JSON payloads when the <code>Content-Type</code> header is <code>application/json</code>.</p> <pre><code>$app-&gt;post('/api/data', function (Request $req, Response $res) {\n    $data = $req-&gt;getJson();\n    $res-&gt;withJson(['received' =&gt; $data])-&gt;send();\n});\n</code></pre> <p>If the request body isn\u2019t valid JSON, you can safely handle it:</p> <pre><code>if ($req-&gt;getJsonError()) {\n    $res-&gt;withError(400, \"Invalid JSON: \" . $req-&gt;getJsonError())-&gt;send();\n    return;\n}\n</code></pre>"},{"location":"concepts/requests/#headers-and-metadata","title":"Headers and Metadata","text":"<pre><code>$agent = $req-&gt;getHeader('User-Agent');\n$all   = $req-&gt;getHeaders();\n\nif ($req-&gt;isSecure()) {\n    // Request made over HTTPS\n}\n\nif ($req-&gt;isAjax()) {\n    // X-Requested-With: XMLHttpRequest\n}\n</code></pre>"},{"location":"concepts/requests/#accessing-files","title":"Accessing Files","text":"<p>Uploaded files are available through <code>getFile()</code> or <code>getFiles()</code>:</p> <pre><code>$file = $req-&gt;getFile('avatar');\n\nif ($file &amp;&amp; $file['error'] === UPLOAD_ERR_OK) {\n    move_uploaded_file($file['tmp_name'], 'uploads/' . $file['name']);\n}\n</code></pre> <p>For multiple uploads under the same key:</p> <pre><code>$file1 = $req-&gt;getFile('images', 0);\n$file2 = $req-&gt;getFile('images', 1);\n</code></pre>"},{"location":"concepts/requests/#getting-client-info","title":"Getting Client Info","text":"<pre><code>$ip = $req-&gt;getIp();\n$ua = $req-&gt;getUserAgent();\n</code></pre> <p>The IP detection respects proxy headers like <code>X-Forwarded-For</code>, but always falls back to <code>REMOTE_ADDR</code>.</p>"},{"location":"concepts/requests/#handling-tokens-or-auth-checks","title":"Handling Tokens or Auth Checks","text":"<p>Because the <code>Request</code> gives you direct access to headers and params, you can implement lightweight auth guards easily:</p> <pre><code>if ($req-&gt;getQueryParam('token') !== 'secret') {\n    $res-&gt;withText('Unauthorized')-&gt;setStatusCode(401)-&gt;send();\n    return;\n}\n</code></pre> <p>Combine with middleware</p> <p>For real-world applications, prefer wrapping authentication or validation logic in a middleware \u2014 it\u2019s cleaner and reusable across multiple routes.</p>"},{"location":"concepts/requests/#low-level-access","title":"Low-level Access","text":"<p>When needed, you can also inspect the raw body or decoded JSON directly:</p> <pre><code>$raw = $req-&gt;getRawBody();\n$json = $req-&gt;getJson(true); // associative array\n</code></pre>"},{"location":"concepts/requests/#summary","title":"Summary","text":"Method Description <code>getQueryParam($key, $default)</code> Read query string values <code>getFormDataParam($key, $default)</code> Read POST form fields <code>getJson()</code> Decode JSON payloads <code>getHeader($name)</code> Retrieve a header <code>getFile($key)</code> Get uploaded file info <code>getIp()</code> / <code>getUserAgent()</code> Access client metadata <code>isAjax()</code> / <code>isSecure()</code> Detect request type <p>Under the hood</p> <p>Request sanitizes all query and form values automatically with <code>htmlspecialchars()</code> to prevent accidental HTML injection.</p>"},{"location":"concepts/responses/","title":"Handling Responses","text":"<p>The <code>Response</code> object in Erlenmeyer gives you full control over what is sent back to the client \u2014 whether it\u2019s plain text, HTML, JSON, or file downloads.</p> <p>It\u2019s designed to be explicit and immutable: each method returns the same <code>Response</code> instance, allowing for fluent chaining and predictable output.</p>"},{"location":"concepts/responses/#sending-basic-responses","title":"Sending Basic Responses","text":"<p>The simplest way to send a response:</p> <pre><code>$app-&gt;get('/hello', function ($req, $res) {\n    $res-&gt;withText('Hello, world!')-&gt;send();\n});\n</code></pre> <p>This sets a <code>Content-Type: text/plain; charset=UTF-8</code> header and flushes the text directly to the client.</p>"},{"location":"concepts/responses/#sending-html","title":"Sending HTML","text":"<pre><code>$app-&gt;get('/', function ($req, $res) {\n    $html = \"&lt;h1&gt;Welcome to Erlenmeyer \u2697\ufe0f&lt;/h1&gt;\";\n    $res-&gt;withHtml($html)-&gt;send();\n});\n</code></pre> <p>By default, the framework adds:</p> <pre><code>Content-Type: text/html; charset=UTF-8\n</code></pre>"},{"location":"concepts/responses/#sending-json","title":"Sending JSON","text":"<pre><code>$app-&gt;get('/api/info', function ($req, $res) {\n    $data = ['status' =&gt; 'ok', 'framework' =&gt; 'Erlenmeyer'];\n    $res-&gt;withJson($data)-&gt;send();\n});\n</code></pre> <p>Internally, <code>withJson()</code>:</p> <ul> <li>Encodes arrays and objects via <code>json_encode()</code>,</li> <li>Sets the <code>Content-Type: application/json</code> header,</li> <li>And automatically applies UTF-8 encoding.</li> </ul>"},{"location":"concepts/responses/#setting-status-codes","title":"Setting Status Codes","text":"<p>You can easily set status codes before sending:</p> <pre><code>$res-&gt;withText('Unauthorized')-&gt;setStatusCode(401)-&gt;send();\n</code></pre> <p>or chain fluently:</p> <pre><code>$res-&gt;setStatusCode(201)-&gt;withJson(['created' =&gt; true])-&gt;send();\n</code></pre>"},{"location":"concepts/responses/#redirects","title":"Redirects","text":"<p>Redirects are just another response type:</p> <pre><code>$res-&gt;redirect('/new-location');\n</code></pre> <p>You can specify whether it\u2019s permanent:</p> <pre><code>$res-&gt;redirect('/new-home', 301);\n</code></pre>"},{"location":"concepts/responses/#custom-headers","title":"Custom Headers","text":"<p>Add or replace headers using <code>setHeader()</code>:</p> <pre><code>$res-&gt;setHeader('X-Powered-By', 'Erlenmeyer')\n    -&gt;withText('OK')\n    -&gt;send();\n</code></pre> <p>Or multiple at once:</p> <pre><code>$res-&gt;setHeaders([\n    'Cache-Control' =&gt; 'no-store',\n    'X-Frame-Options' =&gt; 'DENY',\n])-&gt;withText('Secure')-&gt;send();\n</code></pre>"},{"location":"concepts/responses/#sending-files","title":"Sending Files","text":"<p>For binary or downloadable responses:</p> <pre><code>$app-&gt;get('/download', function ($req, $res) {\n    $res-&gt;withFile('assets/banner.jpg')-&gt;send();\n});\n</code></pre> <p>This automatically sets the correct MIME type and streams the file content.</p>"},{"location":"concepts/responses/#json-error-helpers","title":"JSON Error Helpers","text":"<p>For quick API responses:</p> <pre><code>$res-&gt;withError(404, 'Not found')-&gt;send();\n</code></pre> <p>This produces a JSON body like:</p> <pre><code>{\n  \"error\": \"Not found\",\n  \"status\": 404\n}\n</code></pre> <p>and sets both <code>Content-Type: application/json</code> and HTTP 404.</p>"},{"location":"concepts/responses/#working-with-cookies","title":"Working with Cookies","text":"<p>You can add cookies easily:</p> <pre><code>$res-&gt;setCookie('session', 'abc123', [\n    'path' =&gt; '/',\n    'httponly' =&gt; true,\n    'secure' =&gt; true,\n]);\n</code></pre> <p>And clear them:</p> <pre><code>$res-&gt;clearCookie('session');\n</code></pre>"},{"location":"concepts/responses/#combining-responses-and-middleware","title":"Combining Responses and Middleware","text":"<p>Because the response is mutable, it can be safely modified in middlewares:</p> <pre><code>$headers = function ($req, $res, $next, $params) {\n    $res-&gt;setHeader('X-Request-ID', uniqid());\n    $next($req, $res, $params);\n};\n</code></pre> <p>Functional design</p> <p>Middlewares and handlers share the same <code>Response</code> instance, so all mutations (headers, status codes, cookies) persist across the chain.</p>"},{"location":"concepts/responses/#full-example","title":"Full Example","text":"<pre><code>$app-&gt;get('/profile', function ($req, $res) {\n    $user = ['id' =&gt; 1, 'name' =&gt; 'Ada Lovelace'];\n\n    $res-&gt;setHeader('X-Powered-By', 'Erlenmeyer')\n        -&gt;setStatusCode(200)\n        -&gt;withJson($user)\n        -&gt;send();\n});\n</code></pre> <p>Response headers:</p> <pre><code>HTTP/1.1 200 OK\nContent-Type: application/json; charset=UTF-8\nX-Powered-By: Erlenmeyer\n</code></pre> <p>Body:</p> <pre><code>{ \"id\": 1, \"name\": \"Ada Lovelace\" }\n</code></pre>"},{"location":"concepts/responses/#summary","title":"Summary","text":"Method Description <code>withText($text)</code> Sends plain text <code>withHtml($html)</code> Sends HTML content <code>withJson($data)</code> Sends JSON payload <code>withFile($path)</code> Streams a file <code>setHeader($key, $value)</code> Sets a single header <code>setHeaders(array $headers)</code> Sets multiple headers <code>setStatusCode($code)</code> Sets HTTP status <code>redirect($url, $code = 302)</code> Redirects the request <code>withError($code, $message)</code> Sends a JSON error <code>setCookie()</code> / <code>clearCookie()</code> Manage cookies <p>Under the hood</p> <p>Erlenmeyer buffers all response data until you call <code>send()</code>. This gives you freedom to build, modify, and compose responses before anything is sent to the client \u2014 full control, zero magic.</p>"},{"location":"concepts/routing/","title":"Routing","text":"<p>Routing in Erlenmeyer follows the same philosophy as the rest of the framework: simplicity and clarity first. You declare routes directly on the <code>App</code> instance \u2014 no separate route files or rigid structures required.</p>"},{"location":"concepts/routing/#how-routing-works","title":"How routing works","text":"<p>At its core, routing is managed by the <code>App</code> class. Each route maps an HTTP method and a URI pattern to a callable handler:</p> <pre><code>$app-&gt;get('/hello', function (Request $req, Response $res) {\n    $res-&gt;withText('Hello world!')-&gt;send();\n});\n</code></pre> <p>Under the hood, routes are stored internally as regular expressions, allowing Erlenmeyer to support dynamic parameters and even fallback routes.</p>"},{"location":"concepts/routing/#dynamic-parameters","title":"Dynamic parameters","text":"<p>Parameters are enclosed in square brackets <code>[]</code>, and are automatically converted into named regex groups:</p> <pre><code>$app-&gt;get('/users/[id]', function ($req, $res, $params) {\n    $res-&gt;withJson(['id' =&gt; $params-&gt;id])-&gt;send();\n});\n</code></pre> <p>You can use as many parameters as you need, and Erlenmeyer will map them into a <code>$params</code> object:</p> <pre><code>$app-&gt;get('/posts/[year]/[slug]', fn($req, $res, $p)\n    =&gt; $res-&gt;withJson($p)-&gt;send());\n</code></pre> <p>Internally, <code>/users/[id]</code> becomes:</p> <pre><code>/^\\/users\\/([a-zA-Z0-9\\.\\-_]+)$/\n</code></pre>"},{"location":"concepts/routing/#route-methods","title":"Route methods","text":"<p>You can register routes for any HTTP verb, or for multiple ones at once:</p> <pre><code>$app-&gt;get('/users', ...);\n$app-&gt;post('/users', ...);\n$app-&gt;put('/users/[id]', ...);\n$app-&gt;delete('/users/[id]', ...);\n$app-&gt;patch('/users/[id]', ...);\n</code></pre> <p>Or combine several in one call:</p> <pre><code>$app-&gt;match(['GET', 'POST'], '/contact', ...);\n$app-&gt;any('/ping', ...); // handles all methods\n</code></pre>"},{"location":"concepts/routing/#redirects","title":"Redirects","text":"<p>Simple route redirection is built in:</p> <pre><code>$app-&gt;redirect('/old-home', '/new-home');\n$app-&gt;redirect('/legacy', '/', permanent: true);\n</code></pre> <p>The second parameter defines the destination, and the optional <code>permanent</code> flag triggers a 301 redirect instead of 302.</p>"},{"location":"concepts/routing/#fallbacks-and-404s","title":"Fallbacks and 404s","text":"<p>If no route matches, Erlenmeyer will:</p> <ol> <li>Try to serve a static file through the <code>Assets</code> manager (if configured);</li> <li>Otherwise, call the 404 handler.</li> </ol> <p>You can customize the 404 handler at any time:</p> <pre><code>$app-&gt;set404Handler(function ($req, $res) {\n    $res-&gt;setStatusCode(404)-&gt;withHtml('&lt;h1&gt;Not found&lt;/h1&gt;')-&gt;send();\n});\n</code></pre>"},{"location":"concepts/routing/#middlewares","title":"Middlewares","text":"<p>Each route can have its own middleware chain. A middleware receives a <code>$next()</code> callback to continue the execution flow:</p> <pre><code>$auth = function ($req, $res, $next, $params) {\n    if ($req-&gt;getQueryParam('token') !== 'secret') {\n        $res-&gt;withText('Unauthorized')-&gt;setStatusCode(401)-&gt;send();\n        return;\n    }\n    $next($req, $res, new stdClass());\n};\n\n$app-&gt;get('/secure', fn($req, $res) =&gt; $res-&gt;withText('Welcome!')-&gt;send(), [$auth]);\n</code></pre> <p>You can also register global middlewares:</p> <pre><code>$app-&gt;addMiddleware($auth);\n</code></pre> <p>They will be applied to every route automatically.</p>"},{"location":"concepts/routing/#under-the-hood","title":"Under the hood","text":"<ul> <li>The <code>App</code> class keeps an internal map of routes by method.</li> <li>Each route is stored as a regex pattern and a handler.</li> <li>When a request arrives, <code>handle()</code> loops through the registered routes, testing each pattern with <code>preg_match</code>.</li> <li>If a match is found, parameters are mapped into an object and passed to the handler.</li> <li>If none match, the fallback or 404 handler is invoked.</li> </ul> <p>This simple mechanism allows Erlenmeyer to remain lightweight, predictable, and easy to debug.</p>"},{"location":"concepts/sessions/","title":"Sessions","text":"<p>Erlenmeyer provides a simple, static <code>Session</code> class for working with PHP sessions in a clean and expressive way \u2014 no need to deal with <code>$_SESSION</code> directly.</p> <p>It supports regular session data and one-time flash messages, making it ideal for login states, form feedback, or transient notifications.</p>"},{"location":"concepts/sessions/#overview","title":"\ud83e\udde9 Overview","text":"<p>The <code>Session</code> class wraps PHP\u2019s native session API and ensures that a session is always started automatically when needed.</p> <p>You can store, retrieve, check, and remove session data with clear, predictable methods.</p> <p>Example:</p> <pre><code>use AdaiasMagdiel\\Erlenmeyer\\Session;\n\n// Store user data\nSession::set('user_id', 42);\n\n// Retrieve it later\n$userId = Session::get('user_id');\n\n// Check existence\nif (Session::has('user_id')) {\n    echo \"User logged in\";\n}\n</code></pre>"},{"location":"concepts/sessions/#starting-a-session","title":"\u2699\ufe0f Starting a Session","text":"<p>You don\u2019t need to call <code>session_start()</code> manually \u2014 Erlenmeyer does this automatically whenever you interact with <code>Session</code>.</p> <p>If a session isn\u2019t active yet, it\u2019s started transparently.</p>"},{"location":"concepts/sessions/#basic-api","title":"\ud83e\uddf1 Basic API","text":""},{"location":"concepts/sessions/#storing-and-retrieving-values","title":"Storing and Retrieving Values","text":"<pre><code>Session::set('theme', 'dark');\n\necho Session::get('theme');        // \"dark\"\necho Session::get('language', 'en'); // default fallback: \"en\"\n</code></pre>"},{"location":"concepts/sessions/#checking-and-removing","title":"Checking and Removing","text":"<pre><code>if (Session::has('theme')) {\n    Session::remove('theme');\n}\n</code></pre>"},{"location":"concepts/sessions/#flash-messages","title":"\u26a1 Flash Messages","text":"<p>Flash messages are temporary session values that last for one request only.</p> <p>They\u2019re perfect for redirect-based workflows \u2014 for example, after a form submission.</p> <pre><code>// On form submission\nSession::flash('success', 'User created successfully!');\nreturn $res-&gt;redirect(\"/login\");\n</code></pre> <pre><code>// On the redirected page\n$message = Session::getFlash('success');\n\nif ($message) {\n    echo \"&lt;p class='alert alert-success'&gt;{$message}&lt;/p&gt;\";\n}\n</code></pre> <p>The message is automatically removed after being retrieved.</p>"},{"location":"concepts/sessions/#how-it-works","title":"\ud83e\udde0 How It Works","text":"<ul> <li>Flash messages are stored internally under the <code>$_SESSION['flash']</code> array.</li> <li>When you call <code>getFlash()</code>, the item is returned and immediately removed.</li> <li>If the flash container becomes empty, it\u2019s cleared completely.</li> </ul> <p>Example:</p> <pre><code>Session::flash('notice', 'Settings saved!');\necho Session::getFlash('notice'); // Displays and removes the message\necho Session::getFlash('notice'); // null\n</code></pre>"},{"location":"concepts/sessions/#complete-api-reference","title":"\ud83e\udde9 Complete API Reference","text":"Method Description <code>Session::set($key, $value)</code> Stores a value in the session <code>Session::get($key, $default = null)</code> Retrieves a value or default <code>Session::has($key)</code> Checks if a key exists <code>Session::remove($key)</code> Removes a key from the session <code>Session::flash($key, $value)</code> Sets a temporary one-request message <code>Session::getFlash($key, $default = null)</code> Retrieves and removes a flash message <code>Session::hasFlash($key)</code> Checks if a flash message exists"},{"location":"concepts/sessions/#example-login-system","title":"\ud83e\udde9 Example: Login System","text":"<pre><code>$app-&gt;post('/login', function ($req, $res) {\n    $user = authenticate($req-&gt;getFormDataParam('email'), $req-&gt;getFormDataParam('password'));\n\n    if (!$user) {\n        Session::flash('error', 'Invalid credentials');\n        return $res-&gt;redirect('/login');\n    }\n\n    Session::set('user', $user['id']);\n    return $res-&gt;redirect('/dashboard');\n});\n\n$app-&gt;get('/dashboard', function ($req, $res) {\n    if (!Session::has('user')) {\n        return $res-&gt;redirect('/login');\n    }\n\n    $res-&gt;withHtml('&lt;h1&gt;Welcome to your dashboard&lt;/h1&gt;')-&gt;send();\n});\n</code></pre> <p>This demonstrates how you can combine sessions and flash messages to manage authentication in just a few lines.</p>"},{"location":"concepts/sessions/#notes-best-practices","title":"\u2696\ufe0f Notes &amp; Best Practices","text":"<p>\u2705 Sessions are automatically started when needed. \u274c Do not call <code>session_start()</code> manually \u2014 Erlenmeyer handles it. \ud83e\udde9 Flash data is temporary \u2014 once read, it\u2019s gone. \ud83d\udd12 Always validate user input before storing it in the session.</p>"},{"location":"concepts/sessions/#summary","title":"\ud83d\ude80 Summary","text":"Concept Description Persistent data Store and retrieve session values easily Flash messages Temporary data for redirects and notices Auto-start Sessions start automatically on first use Clean API No direct access to <code>$_SESSION</code> Stateless testing Works seamlessly with <code>ErlenClient</code> for request simulation <p>Pro tip</p> <p>Combine <code>Session::flash()</code> with <code>Response::redirect()</code> to create elegant, user-friendly feedback loops \u2014 perfect for form submissions or login flows.</p>"},{"location":"guides/building-an-api/","title":"Building an API","text":"<p>Erlenmeyer makes it simple to build clean, lightweight, and fully structured APIs \u2014 with routes, middleware, error handling, and JSON responses \u2014 all in plain PHP.</p> <p>This guide walks you through creating a basic RESTful API step by step.</p>"},{"location":"guides/building-an-api/#project-setup","title":"\ud83e\udde9 Project Setup","text":"<p>Create a new project folder:</p> <pre><code>mkdir my-api\ncd my-api\n</code></pre> <p>Install Erlenmeyer via Composer:</p> <pre><code>composer require adaiasmagdiel/erlenmeyer\n</code></pre> <p>Create the main entry point:</p> <pre><code>my-api/\n\u2514\u2500\u2500 public/\n    \u2514\u2500\u2500 index.php\n</code></pre>"},{"location":"guides/building-an-api/#basic-application","title":"\u2699\ufe0f Basic Application","text":"<p>Start by creating a minimal API that returns a JSON response.</p> <pre><code>&lt;?php\nrequire __DIR__ . '/../vendor/autoload.php';\n\nuse AdaiasMagdiel\\Erlenmeyer\\App;\nuse AdaiasMagdiel\\Erlenmeyer\\Request;\nuse AdaiasMagdiel\\Erlenmeyer\\Response;\n\n$app = new App();\n\n$app-&gt;get('/hello', function (Request $req, Response $res, stdClass $params): Response {\n    return $res-&gt;withJson(['message' =&gt; 'Hello, API!']);\n});\n\n$app-&gt;run();\n</code></pre> <p>Now run the built-in PHP server:</p> <pre><code>php -S localhost:8000 -t public\n</code></pre> <p>Visit: \ud83d\udc49 http://localhost:8000/hello</p> <p>You should see:</p> <pre><code>{ \"message\": \"Hello, API!\" }\n</code></pre>"},{"location":"guides/building-an-api/#defining-routes","title":"\ud83e\uddf1 Defining Routes","text":"<p>Erlenmeyer supports all common HTTP verbs:</p> <pre><code>$app-&gt;get('/users', $handler);\n$app-&gt;post('/users', $handler);\n$app-&gt;put('/users/[id]', $handler);\n$app-&gt;delete('/users/[id]', $handler);\n</code></pre>"},{"location":"guides/building-an-api/#example","title":"Example","text":"<pre><code>use AdaiasMagdiel\\Erlenmeyer\\Request;\nuse AdaiasMagdiel\\Erlenmeyer\\Response;\n\n$users = [\n    ['id' =&gt; 1, 'name' =&gt; 'Alice'],\n    ['id' =&gt; 2, 'name' =&gt; 'Bob'],\n];\n\n$app-&gt;get('/users', function (Request $req, Response $res, stdClass $params): Response {\n    global $users;\n    return $res-&gt;withJson($users);\n});\n\n$app-&gt;get('/users/[id]', function (Request $req, Response $res, stdClass $params): Response {\n    global $users;\n\n    $id = (int) $params-&gt;id;\n    $user = array_values(array_filter($users, fn($u) =&gt; $u['id'] === $id))[0] ?? null;\n\n    if (!$user) {\n        return $res-&gt;withJson(['error' =&gt; 'User not found'])\n                   -&gt;setStatusCode(404);\n    }\n\n    return $res-&gt;withJson($user);\n});\n</code></pre>"},{"location":"guides/building-an-api/#handling-json-requests","title":"\ud83e\udde9 Handling JSON Requests","text":"<p>To read JSON input from the client:</p> <pre><code>use AdaiasMagdiel\\Erlenmeyer\\Request;\nuse AdaiasMagdiel\\Erlenmeyer\\Response;\n\n$app-&gt;post('/users', function (Request $req, Response $res, stdClass $params): Response {\n    $data = $req-&gt;getJson(true);\n\n    if (!$data || empty($data['name'])) {\n        return $res-&gt;withJson(['error' =&gt; 'Invalid input'])\n                   -&gt;setStatusCode(400);\n    }\n\n    return $res-&gt;withJson([\n        'message' =&gt; 'User created successfully',\n        'user' =&gt; $data,\n    ])-&gt;setStatusCode(201);\n});\n</code></pre>"},{"location":"guides/building-an-api/#using-middleware","title":"\ud83e\udde0 Using Middleware","text":"<p>Middleware can handle cross-cutting concerns such as authentication or logging.</p> <pre><code>use AdaiasMagdiel\\Erlenmeyer\\Request;\nuse AdaiasMagdiel\\Erlenmeyer\\Response;\n\n$app-&gt;addMiddleware(function (Request $req, Response $res, callable $next, stdClass $params): void {\n    $token = $req-&gt;getHeader('Authorization');\n\n    if ($token !== 'Bearer secret123') {\n        $res-&gt;withJson(['error' =&gt; 'Unauthorized'])\n            -&gt;setStatusCode(401)\n            -&gt;send();\n        return;\n    }\n\n    $next($req, $res, $params);\n});\n</code></pre> <p>This will run before every route \u2014 you can also apply it to specific routes if needed.</p>"},{"location":"guides/building-an-api/#error-handling","title":"\ud83e\uddf0 Error Handling","text":"<p>Erlenmeyer lets you define custom error handlers for exceptions or HTTP 404s.</p> <pre><code>use Throwable;\n\n$app-&gt;set404Handler(function (Request $req, Response $res) {\n    $res-&gt;withJson(['error' =&gt; 'Endpoint not found'])\n        -&gt;setStatusCode(404)\n        -&gt;send();\n});\n\n$app-&gt;setExceptionHandler(Throwable::class, function (Request $req, Response $res, Throwable $e) {\n    $res-&gt;withJson([\n        'error' =&gt; 'Server error',\n        'message' =&gt; $e-&gt;getMessage(),\n    ])-&gt;setStatusCode(500)-&gt;send();\n});\n</code></pre>"},{"location":"guides/building-an-api/#testing-the-api","title":"\ud83e\uddea Testing the API","text":"<p>You can use ErlenClient to test your API routes programmatically.</p> <pre><code>use AdaiasMagdiel\\Erlenmeyer\\ErlenClient;\n\n$client = new ErlenClient($app);\n\n$response = $client-&gt;get('/users');\necho $response-&gt;getBody();\n</code></pre> <p>This simulates HTTP requests without running a web server \u2014 perfect for automated testing.</p>"},{"location":"guides/building-an-api/#full-example","title":"\ud83e\udde9 Full Example","text":"<p>Here\u2019s a small but complete API that supports listing, adding, and fetching users:</p> <pre><code>&lt;?php\nrequire __DIR__ . '/../vendor/autoload.php';\n\nuse AdaiasMagdiel\\Erlenmeyer\\App;\nuse AdaiasMagdiel\\Erlenmeyer\\Request;\nuse AdaiasMagdiel\\Erlenmeyer\\Response;\n\n$app = new App();\n\n$users = [\n    ['id' =&gt; 1, 'name' =&gt; 'Alice'],\n    ['id' =&gt; 2, 'name' =&gt; 'Bob'],\n];\n\n$app-&gt;get('/users', function (Request $req, Response $res, stdClass $params): Response {\n    global $users;\n    return $res-&gt;withJson($users);\n});\n\n$app-&gt;get('/users/[id]', function (Request $req, Response $res, stdClass $params): Response {\n    global $users;\n    $id = (int) $params-&gt;id;\n    $user = array_values(array_filter($users, fn($u) =&gt; $u['id'] === $id))[0] ?? null;\n\n    if (!$user) {\n        return $res-&gt;withJson(['error' =&gt; 'User not found'])\n                   -&gt;setStatusCode(404);\n    }\n\n    return $res-&gt;withJson($user);\n});\n\n$app-&gt;post('/users', function (Request $req, Response $res, stdClass $params): Response {\n    global $users;\n\n    $data = $req-&gt;getJson();\n    $id = count($users) + 1;\n\n    $user = ['id' =&gt; $id, 'name' =&gt; $data['name']];\n    $users[] = $user;\n\n    return $res-&gt;withJson([\n        'message' =&gt; 'User added',\n        'user' =&gt; $user,\n    ])-&gt;setStatusCode(201);\n});\n\n$app-&gt;run();\n</code></pre> <p>Run it, then test with:</p> <pre><code>curl http://localhost:8000/users\ncurl http://localhost:8000/users/1\ncurl -X POST -H \"Content-Type: application/json\" \\\n     -d '{\"name\": \"Charlie\"}' http://localhost:8000/users\n</code></pre>"},{"location":"guides/building-an-api/#summary","title":"\ud83d\ude80 Summary","text":"Concept Description Routes Define endpoints for GET, POST, PUT, DELETE JSON Use <code>withJson()</code> for structured responses Requests Parse body with <code>$req-&gt;getJson()</code> Middleware Handle authentication, logging, etc. Errors Customize 404 and exception handlers Testing Use <code>ErlenClient</code> to simulate API calls <p>Keep it modular</p> <p>For larger APIs, organize your routes into separate files or controllers \u2014 Erlenmeyer is flexible enough to scale cleanly without adding complexity.</p>"},{"location":"guides/handling-cors-and-auth/","title":"Handling CORS and Authentication","text":"<p>Erlenmeyer makes it easy to handle CORS (Cross-Origin Resource Sharing) and authentication through global middleware \u2014 giving you full control over access, headers, and user data at a single entry point.</p>"},{"location":"guides/handling-cors-and-auth/#why-global-middleware","title":"\ud83e\udde9 Why Global Middleware?","text":"<p>A global middleware in Erlenmeyer runs before all routes, even if a route has not been explicitly registered.</p> <p>This means you can:</p> <ul> <li>Respond to <code>OPTIONS</code> preflight requests automatically (perfect for CORS).</li> <li>Inject authenticated user data into <code>$params</code> before any route handler executes.</li> </ul> <p>That\u2019s what makes Erlenmeyer\u2019s middleware system both flexible and powerful.</p>"},{"location":"guides/handling-cors-and-auth/#enabling-cors-with-global-middleware","title":"\u2699\ufe0f Enabling CORS with Global Middleware","text":"<p>Let\u2019s start with CORS \u2014 Cross-Origin Resource Sharing.</p> <p>Browsers send an <code>OPTIONS</code> request automatically to check whether the target domain allows the main request.</p> <p>With a global middleware, you can intercept every request \u2014 including <code>OPTIONS</code> \u2014 and handle CORS headers without registering separate routes.</p>"},{"location":"guides/handling-cors-and-auth/#example","title":"Example","text":"<pre><code>use AdaiasMagdiel\\Erlenmeyer\\Request;\nuse AdaiasMagdiel\\Erlenmeyer\\Response;\n\n$app-&gt;addMiddleware(function (Request $req, Response $res, callable $next, stdClass $params): void {\n    // Apply CORS headers to every request\n    $res-&gt;setCORS([\n        'origin' =&gt; '*',\n        'methods' =&gt; ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n        'headers' =&gt; ['Content-Type', 'Authorization'],\n        'credentials' =&gt; false,\n        'max_age' =&gt; 86400, // cache preflight response for 1 day\n    ]);\n\n    // Handle preflight requests automatically\n    if ($req-&gt;getMethod() === 'OPTIONS') {\n        $res-&gt;setStatusCode(204)-&gt;send();\n        return;\n    }\n\n    // Continue to next middleware or route\n    $next($req, $res, $params);\n});\n</code></pre>"},{"location":"guides/handling-cors-and-auth/#key-advantages","title":"\u2705 Key Advantages","text":"<ul> <li>Works even if no route is defined for <code>OPTIONS</code>.</li> <li>Runs before assets, 404, or any route handler.</li> <li>Keeps your route definitions clean and focused.</li> </ul>"},{"location":"guides/handling-cors-and-auth/#authentication-middleware","title":"\ud83d\udd12 Authentication Middleware","text":"<p>Now, let\u2019s handle authentication.</p> <p>You can use another global middleware (or combine both in one) to check for a token, validate it, and inject a user object into <code>$params</code>.</p> <p>That way, every route automatically receives the current authenticated user.</p>"},{"location":"guides/handling-cors-and-auth/#example-bearer-token-auth","title":"Example: Bearer Token Auth","text":"<pre><code>use AdaiasMagdiel\\Erlenmeyer\\Request;\nuse AdaiasMagdiel\\Erlenmeyer\\Response;\n\n$app-&gt;addMiddleware(function (Request $req, Response $res, callable $next, stdClass $params): void {\n    $authHeader = $req-&gt;getHeader('Authorization');\n\n    if (!$authHeader || !str_starts_with($authHeader, 'Bearer ')) {\n        $res-&gt;withJson(['error' =&gt; 'Missing or invalid Authorization header'])\n            -&gt;setStatusCode(401)\n            -&gt;send();\n        return;\n    }\n\n    $token = substr($authHeader, 7);\n\n    // Simulate token validation (replace with your logic)\n    $user = match ($token) {\n        'secret123' =&gt; (object) ['id' =&gt; 1, 'name' =&gt; 'Alice'],\n        'admin456'  =&gt; (object) ['id' =&gt; 2, 'name' =&gt; 'Bob', 'role' =&gt; 'admin'],\n        default     =&gt; null,\n    };\n\n    if (!$user) {\n        $res-&gt;withJson(['error' =&gt; 'Unauthorized'])\n            -&gt;setStatusCode(401)\n            -&gt;send();\n        return;\n    }\n\n    // Inject the user into route parameters\n    $params-&gt;user = $user;\n\n    // Continue with the request\n    $next($req, $res, $params);\n});\n</code></pre> <p>Now every route can access the authenticated user via <code>$params-&gt;user</code>.</p>"},{"location":"guides/handling-cors-and-auth/#example-protected-routes","title":"\ud83e\uddf1 Example: Protected Routes","text":"<pre><code>use AdaiasMagdiel\\Erlenmeyer\\Request;\nuse AdaiasMagdiel\\Erlenmeyer\\Response;\n\n$app-&gt;get('/profile', function (Request $req, Response $res, stdClass $params): Response {\n    if (empty($params-&gt;user)) {\n        return $res-&gt;withJson(['error' =&gt; 'Not authenticated'])-&gt;setStatusCode(401);\n    }\n\n    return $res-&gt;withJson([\n        'id' =&gt; $params-&gt;user-&gt;id,\n        'name' =&gt; $params-&gt;user-&gt;name,\n    ]);\n});\n</code></pre> <p>This route will only respond successfully if <code>$params-&gt;user</code> was injected by your authentication middleware.</p>"},{"location":"guides/handling-cors-and-auth/#combining-cors-and-auth","title":"\ud83e\udde9 Combining CORS and Auth","text":"<p>You can easily combine both middlewares \u2014 order matters!</p> <ol> <li>The CORS middleware should run first (to handle preflight and headers).</li> <li>The auth middleware should run second (to check tokens only for valid requests).</li> </ol>"},{"location":"guides/handling-cors-and-auth/#example_1","title":"Example","text":"<pre><code>// 1\ufe0f\u20e3 CORS middleware\n$app-&gt;addMiddleware(function (Request $req, Response $res, callable $next, stdClass $params): void {\n    $res-&gt;setCORS([\n        'origin' =&gt; '*',\n        'methods' =&gt; ['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS'],\n        'headers' =&gt; ['Content-Type', 'Authorization'],\n    ]);\n\n    if ($req-&gt;getMethod() === 'OPTIONS') {\n        $res-&gt;setStatusCode(204)-&gt;send();\n        return;\n    }\n\n    $next($req, $res, $params);\n});\n\n// 2\ufe0f\u20e3 Auth middleware\n$app-&gt;addMiddleware(function (Request $req, Response $res, callable $next, stdClass $params): void {\n    $authHeader = $req-&gt;getHeader('Authorization');\n\n    if (!$authHeader) {\n        $res-&gt;withJson(['error' =&gt; 'Unauthorized'])-&gt;setStatusCode(401)-&gt;send();\n        return;\n    }\n\n    $params-&gt;user = (object) ['id' =&gt; 1, 'name' =&gt; 'ExampleUser']; // Example\n    $next($req, $res, $params);\n});\n</code></pre> <p>This ensures that all responses have proper CORS headers and that authenticated routes can safely access <code>$params-&gt;user</code>.</p>"},{"location":"guides/handling-cors-and-auth/#testing-with-erlenclient","title":"\ud83e\uddea Testing with ErlenClient","text":"<p>You can simulate preflight and authenticated requests easily:</p> <pre><code>use AdaiasMagdiel\\Erlenmeyer\\Testing\\ErlenClient;\n\n$client = new ErlenClient($app);\n\n// Test CORS preflight\n$response = $client-&gt;options('/profile');\necho $response-&gt;getStatusCode(); // 204\n\n// Test authenticated GET\n$response = $client-&gt;get('/profile', [\n    'headers' =&gt; ['Authorization' =&gt; 'Bearer secret123']\n]);\necho $response-&gt;getBody();\n</code></pre> <p>Output:</p> <pre><code>{\n  \"id\": 1,\n  \"name\": \"Alice\"\n}\n</code></pre>"},{"location":"guides/handling-cors-and-auth/#summary","title":"\ud83d\ude80 Summary","text":"Concept Description Global middleware Runs before all routes, even unregistered ones CORS handling Handles OPTIONS and adds CORS headers automatically Auth middleware Validates tokens and injects <code>$params-&gt;user</code> Combined middlewares Handle cross-origin and authentication together Testable Works perfectly with <code>ErlenClient</code>"},{"location":"guides/testing/","title":"Testing Your Application","text":"<p>Erlenmeyer includes a built-in testing utility called ErlenClient, designed to simulate real HTTP requests without a web server.</p> <p>It lets you fully test routes, middlewares, authentication, errors, and even CORS \u2014 directly inside PHP, fast and isolated.</p>"},{"location":"guides/testing/#why-erlenclient","title":"\ud83e\udde9 Why ErlenClient?","text":"<p>ErlenClient acts like a mini HTTP client that runs inside the same process as your app. This means:</p> <ul> <li>No need to start <code>php -S</code> or a local server.</li> <li>Requests pass through the same middleware, routes, and handlers.</li> <li>You can test APIs, sessions, and even global middleware logic easily.</li> </ul>"},{"location":"guides/testing/#basic-setup","title":"\u2699\ufe0f Basic Setup","text":"<p>Let\u2019s start with a simple test structure:</p> <pre><code>project/\n\u251c\u2500\u2500 app/\n\u2502   \u2514\u2500\u2500 App.php\n\u251c\u2500\u2500 tests/\n\u2502   \u251c\u2500\u2500 bootstrap.php\n\u2502   \u2514\u2500\u2500 ExampleTest.php\n\u2514\u2500\u2500 public/\n\u2514\u2500\u2500 index.php\n</code></pre>"},{"location":"guides/testing/#example-testsbootstrapphp","title":"Example: <code>tests/bootstrap.php</code>","text":"<pre><code>&lt;?php\nrequire __DIR__ . '/../vendor/autoload.php';\n\nuse AdaiasMagdiel\\Erlenmeyer\\App;\n\n$app = new App();\n\n$app-&gt;get('/hello', fn($req, $res, $params) =&gt;\n    $res-&gt;withJson(['message' =&gt; 'Hello, Tests!'])\n);\n\nreturn $app;\n</code></pre>"},{"location":"guides/testing/#writing-your-first-test","title":"\ud83e\uddea Writing Your First Test","text":"<pre><code>&lt;?php\nuse AdaiasMagdiel\\Erlenmeyer\\Testing\\ErlenClient;\n\n$app = require __DIR__ . '/bootstrap.php';\n$client = new ErlenClient($app);\n\n$response = $client-&gt;get('/hello');\n\necho $response-&gt;getStatusCode(); // 200\necho $response-&gt;getBody();       // {\"message\":\"Hello, Tests!\"}\n</code></pre> <p>\u2705 This test runs entirely in memory \u2014 no HTTP calls, no external dependencies.</p>"},{"location":"guides/testing/#testing-json-endpoints","title":"\ud83e\uddf1 Testing JSON Endpoints","text":"<p>To simulate a <code>POST</code> request with a JSON body:</p> <pre><code>$response = $client-&gt;post('/users', [\n    'json' =&gt; ['name' =&gt; 'Alice']\n]);\n\necho $response-&gt;getStatusCode(); // 201\necho $response-&gt;getBody();       // {\"message\":\"User created\",\"user\":{\"name\":\"Alice\"}}\n</code></pre>"},{"location":"guides/testing/#assertions-for-phpunit-or-pest","title":"Assertions (for PHPUnit or Pest)","text":"<pre><code>$this-&gt;assertEquals(201, $response-&gt;getStatusCode());\n$this-&gt;assertStringContainsString('Alice', $response-&gt;getBody());\n</code></pre>"},{"location":"guides/testing/#sending-headers-and-tokens","title":"\ud83e\udde9 Sending Headers and Tokens","text":"<p>You can add headers globally or per request.</p>"},{"location":"guides/testing/#global-headers","title":"Global Headers","text":"<pre><code>$client-&gt;withHeaders(['Authorization' =&gt; 'Bearer test123']);\n</code></pre>"},{"location":"guides/testing/#per-request","title":"Per Request","text":"<pre><code>$response = $client-&gt;get('/profile', [\n    'headers' =&gt; ['Authorization' =&gt; 'Bearer test123']\n]);\n</code></pre> <p>All headers are automatically transformed into the proper PHP <code>$_SERVER</code> keys (<code>HTTP_AUTHORIZATION</code>, <code>CONTENT_TYPE</code>, etc.) before dispatch.</p>"},{"location":"guides/testing/#testing-middleware-and-auth","title":"\ud83e\udde0 Testing Middleware and Auth","text":"<p>Global and route-specific middleware logic is fully executed in tests.</p>"},{"location":"guides/testing/#example","title":"Example","text":"<pre><code>$app-&gt;addMiddleware(function ($req, $res, $next, $params) {\n    $token = $req-&gt;getHeader('Authorization');\n    if ($token !== 'Bearer valid123') {\n        $res-&gt;withJson(['error' =&gt; 'Unauthorized'])-&gt;setStatusCode(401)-&gt;send();\n        return;\n    }\n    $params-&gt;user = ['id' =&gt; 1, 'name' =&gt; 'Alice'];\n    $next($req, $res, $params);\n});\n\n$app-&gt;get('/me', fn($req, $res, $params) =&gt;\n    $res-&gt;withJson($params-&gt;user)\n);\n</code></pre> <p>Test:</p> <pre><code>$response = $client-&gt;get('/me', [\n    'headers' =&gt; ['Authorization' =&gt; 'Bearer valid123']\n]);\n\n$this-&gt;assertEquals(200, $response-&gt;getStatusCode());\n$this-&gt;assertStringContainsString('Alice', $response-&gt;getBody());\n</code></pre>"},{"location":"guides/testing/#testing-cors-and-preflight-requests","title":"\ud83e\udde9 Testing CORS and Preflight Requests","text":"<p>CORS is easy to test \u2014 just send an <code>OPTIONS</code> request.</p> <pre><code>$response = $client-&gt;options('/users');\n\n$this-&gt;assertEquals(204, $response-&gt;getStatusCode());\n$this-&gt;assertEquals('*', $response-&gt;getHeaders()['Access-Control-Allow-Origin']);\n</code></pre> <p>If your global middleware sets CORS headers, they will appear in the response automatically.</p>"},{"location":"guides/testing/#testing-query-strings-and-form-data","title":"\u2699\ufe0f Testing Query Strings and Form Data","text":""},{"location":"guides/testing/#query-strings","title":"Query Strings","text":"<pre><code>$response = $client-&gt;get('/search', [\n    'query' =&gt; ['q' =&gt; 'test']\n]);\n\n$this-&gt;assertStringContainsString('test', $response-&gt;getBody());\n</code></pre>"},{"location":"guides/testing/#form-data","title":"Form Data","text":"<pre><code>$response = $client-&gt;post('/submit', [\n    'form_params' =&gt; ['email' =&gt; 'user@example.com']\n]);\n\n$this-&gt;assertEquals(200, $response-&gt;getStatusCode());\n</code></pre>"},{"location":"guides/testing/#testing-file-uploads","title":"\ud83e\uddf1 Testing File Uploads","text":"<p>ErlenClient supports simulated file uploads as well:</p> <pre><code>$response = $client-&gt;post('/upload', [\n    'files' =&gt; [\n        'avatar' =&gt; [\n            'name' =&gt; 'photo.jpg',\n            'type' =&gt; 'image/jpeg',\n            'tmp_name' =&gt; __DIR__ . '/fixtures/photo.jpg',\n            'error' =&gt; 0,\n            'size' =&gt; 2048\n        ]\n    ]\n]);\n</code></pre>"},{"location":"guides/testing/#testing-error-handling","title":"\ud83e\udde9 Testing Error Handling","text":"<p>You can verify custom exception and 404 handlers easily.</p>"},{"location":"guides/testing/#404-example","title":"404 Example","text":"<pre><code>$response = $client-&gt;get('/does-not-exist');\n$this-&gt;assertEquals(404, $response-&gt;getStatusCode());\n</code></pre>"},{"location":"guides/testing/#exception-example","title":"Exception Example","text":"<p>If a route throws an error:</p> <pre><code>$app-&gt;get('/boom', fn() =&gt; throw new Exception('Boom!'));\n</code></pre> <p>Test:</p> <pre><code>$response = $client-&gt;get('/boom');\n$this-&gt;assertEquals(500, $response-&gt;getStatusCode());\n$this-&gt;assertStringContainsString('Boom', $response-&gt;getBody());\n</code></pre>"},{"location":"guides/testing/#session-testing","title":"\ud83e\udde9 Session Testing","text":"<p>Since <code>Session</code> uses the same PHP <code>$_SESSION</code> superglobal, it works normally during tests.</p> <p>You can check flash messages and user data easily.</p> <pre><code>use AdaiasMagdiel\\Erlenmeyer\\Session;\n\nSession::set('user_id', 1);\n$this-&gt;assertEquals(1, Session::get('user_id'));\n\nSession::flash('notice', 'Profile updated!');\n$this-&gt;assertEquals('Profile updated!', Session::getFlash('notice'));\n</code></pre>"},{"location":"guides/testing/#using-phpunit-or-pest","title":"\ud83e\uddf0 Using PHPUnit or Pest","text":"<p>ErlenClient integrates perfectly with modern PHP testing frameworks.</p> <p>Example <code>ExampleTest.php</code> (PHPUnit):</p> <pre><code>&lt;?php\nuse PHPUnit\\Framework\\TestCase;\nuse AdaiasMagdiel\\Erlenmeyer\\Testing\\ErlenClient;\n\nfinal class ExampleTest extends TestCase\n{\n    private ErlenClient $client;\n\n    protected function setUp(): void\n    {\n        $app = require __DIR__ . '/bootstrap.php';\n        $this-&gt;client = new ErlenClient($app);\n    }\n\n    public function testHelloRoute(): void\n    {\n        $response = $this-&gt;client-&gt;get('/hello');\n        $this-&gt;assertEquals(200, $response-&gt;getStatusCode());\n        $this-&gt;assertStringContainsString('Hello', $response-&gt;getBody());\n    }\n}\n</code></pre> <p>Run with:</p> <pre><code>vendor/bin/phpunit\n</code></pre>"},{"location":"guides/testing/#example-full-api-test-suite","title":"\ud83e\udde9 Example: Full API Test Suite","text":"<pre><code>$response = $client-&gt;post('/login', [\n    'json' =&gt; ['email' =&gt; 'user@example.com', 'password' =&gt; 'secret']\n]);\n$this-&gt;assertEquals(200, $response-&gt;getStatusCode());\n\n$response = $client-&gt;get('/profile', [\n    'headers' =&gt; ['Authorization' =&gt; 'Bearer token123']\n]);\n$this-&gt;assertEquals(200, $response-&gt;getStatusCode());\n$this-&gt;assertStringContainsString('user@example.com', $response-&gt;getBody());\n</code></pre>"},{"location":"guides/testing/#summary","title":"\ud83d\ude80 Summary","text":"Concept Description ErlenClient Simulates HTTP requests internally JSON &amp; Form testing Send JSON, form data, and query strings easily CORS testing Test preflight OPTIONS requests Middleware &amp; Auth Fully executed during tests Session Uses real PHP sessions Framework Integration Works with PHPUnit, Pest, or custom scripts"},{"location":"reference/App/","title":"Class: <code>AdaiasMagdiel\\Erlenmeyer\\App</code>","text":"<p>Namespace: <code>AdaiasMagdiel\\Erlenmeyer</code> Defined in: <code>app/App.php</code></p>"},{"location":"reference/App/#overview","title":"Overview","text":"<p>The <code>App</code> class is the core of the Erlenmeyer framework. It provides routing, middleware, static asset handling, error management, and logging.</p>"},{"location":"reference/App/#properties","title":"Properties","text":"Name Visibility Type Description <code>$assets</code> private <code>?Assets</code> Manages static file serving. <code>$logger</code> private <code>LoggerInterface</code> Logger instance for application events and errors. <code>$_404</code> private <code>Closure</code> Custom 404 handler. <code>$globalMiddlewares</code> private <code>array</code> Global middlewares executed on every request. <code>$exceptionHandlers</code> private <code>array</code> Map of exception classes to their handlers. <code>$routes</code> private <code>array</code> Collection of registered routes, grouped by HTTP method. <code>$routePattern</code> private <code>string</code> Regex for identifying dynamic parameters in routes. <code>$paramPattern</code> private <code>string</code> Regex pattern used to replace route parameters."},{"location":"reference/App/#constructor","title":"Constructor","text":""},{"location":"reference/App/#__constructassets-assets-null-loggerinterface-logger-null","title":"<code>__construct(?Assets $assets = null, ?LoggerInterface $logger = null)</code>","text":"<p>Initializes the application, logger, asset manager, and default error handlers.</p>"},{"location":"reference/App/#parameters","title":"Parameters","text":"Name Type Description <code>$assets</code> <code>?Assets</code> Optional <code>Assets</code> instance for static files. <code>$logger</code> <code>?LoggerInterface</code> Optional logger. Defaults to <code>FileLogger</code>."},{"location":"reference/App/#throws","title":"Throws","text":"<ul> <li><code>InvalidArgumentException</code> \u2013 If the assets directory or route is invalid.</li> </ul>"},{"location":"reference/App/#public-methods","title":"Public Methods","text":""},{"location":"reference/App/#setexceptionhandlerstring-throwableclass-callable-handler-void","title":"<code>setExceptionHandler(string $throwableClass, callable $handler): void</code>","text":"<p>Registers a handler for a specific exception type.</p>"},{"location":"reference/App/#parameters_1","title":"Parameters","text":"Name Type Description <code>$throwableClass</code> <code>string</code> Exception class name (must extend <code>Throwable</code>). <code>$handler</code> <code>callable</code> Handler callable <code>(Request $req, Response $res, Throwable $e)</code>."},{"location":"reference/App/#throws_1","title":"Throws","text":"<ul> <li><code>InvalidArgumentException</code> \u2013 If <code>$throwableClass</code> is not a subclass of <code>Throwable</code>.</li> </ul>"},{"location":"reference/App/#getexceptionhandlerthrowable-e-closure","title":"<code>getExceptionHandler(Throwable $e): ?Closure</code>","text":"<p>Retrieves the most specific registered handler for a thrown exception.</p>"},{"location":"reference/App/#parameters_2","title":"Parameters","text":"Name Type Description <code>$e</code> <code>Throwable</code> Exception instance."},{"location":"reference/App/#returns","title":"Returns","text":"<p><code>?Closure</code> \u2013 Matching handler closure or <code>null</code> if none found.</p>"},{"location":"reference/App/#routestring-method-string-route-callable-action-array-middlewares-void","title":"<code>route(string $method, string $route, callable $action, array $middlewares = []): void</code>","text":"<p>Registers a route with an HTTP method and handler.</p>"},{"location":"reference/App/#parameters_3","title":"Parameters","text":"Name Type Description <code>$method</code> <code>string</code> HTTP method (<code>GET</code>, <code>POST</code>, <code>PUT</code>, etc.). <code>$route</code> <code>string</code> Route pattern (supports <code>[param]</code> placeholders). <code>$action</code> <code>callable</code> Handler <code>(Request $req, Response $res, stdClass $params)</code>. <code>$middlewares</code> <code>array</code> Optional middlewares specific to the route."},{"location":"reference/App/#throws_2","title":"Throws","text":"<ul> <li><code>InvalidArgumentException</code> \u2013 If method is invalid.</li> </ul>"},{"location":"reference/App/#http-method-helpers","title":"HTTP Method Helpers","text":"Method Description <code>get(string $route, callable $action, array $middlewares = []): void</code> Registers a <code>GET</code> route. <code>post(string $route, callable $action, array $middlewares = []): void</code> Registers a <code>POST</code> route. <code>put(string $route, callable $action, array $middlewares = []): void</code> Registers a <code>PUT</code> route. <code>delete(string $route, callable $action, array $middlewares = []): void</code> Registers a <code>DELETE</code> route. <code>patch(string $route, callable $action, array $middlewares = []): void</code> Registers a <code>PATCH</code> route. <code>options(string $route, callable $action, array $middlewares = []): void</code> Registers an <code>OPTIONS</code> route. <code>head(string $route, callable $action, array $middlewares = []): void</code> Registers a <code>HEAD</code> route. <code>any(string $route, callable $action, array $middlewares = []): void</code> Registers a handler for all HTTP methods. <code>match(array $methods, string $route, callable $action, array $middlewares = []): void</code> Registers a handler for specific HTTP methods."},{"location":"reference/App/#redirectstring-from-string-to-bool-permanent-false-void","title":"<code>redirect(string $from, string $to, bool $permanent = false): void</code>","text":"<p>Registers an internal redirect from one path to another.</p>"},{"location":"reference/App/#parameters_4","title":"Parameters","text":"Name Type Description <code>$from</code> <code>string</code> Source path. <code>$to</code> <code>string</code> Target path. <code>$permanent</code> <code>bool</code> Whether to use HTTP 301 (<code>true</code>) or 302 (<code>false</code>)."},{"location":"reference/App/#set404handlercallable-action-void","title":"<code>set404Handler(callable $action): void</code>","text":"<p>Registers a custom handler for 404 Not Found responses.</p> <p>The handler must be a callable function with the following signature:</p> <pre><code>function (Request $req, Response $res, stdClass $params): void\n</code></pre>"},{"location":"reference/App/#parameters_5","title":"Parameters","text":"Name Type Description <code>$action</code> <code>callable</code> Function or closure executed when no route matches the request. Must accept <code>(Request $req, Response $res, stdClass $params)</code>."},{"location":"reference/App/#addmiddlewarecallable-middleware-void","title":"<code>addMiddleware(callable $middleware): void</code>","text":"<p>Adds a global middleware applied to all requests.</p> <p>A middleware is a callable function expected to follow this signature:</p> <pre><code>function (Request $req, Response $res, callable $next, stdClass $params): void\n</code></pre> <p>Each middleware can:</p> <ul> <li>Access and modify the <code>Request</code> and <code>Response</code> objects.</li> <li>Call <code>$next($req, $res, $params)</code> to continue execution.</li> <li>Stop the chain (e.g., to send an error or custom response).</li> <li>Optionally inject data into <code>$params</code> for downstream handlers.</li> </ul>"},{"location":"reference/App/#parameters_6","title":"Parameters","text":"Name Type Description <code>$middleware</code> <code>callable</code> A function or closure that matches the signature <code>(Request $req, Response $res, callable $next, stdClass $params): void</code>."},{"location":"reference/App/#run-void","title":"<code>run(): void</code>","text":"<p>Executes the application lifecycle:</p> <ul> <li>Registers PHP error/shutdown handlers</li> <li>Creates request/response instances</li> <li>Dispatches matched routes or assets</li> <li>Sends the final response</li> </ul>"},{"location":"reference/App/#throws_3","title":"Throws","text":"<ul> <li><code>RuntimeException</code> \u2013 If execution fails or headers cannot be sent.</li> </ul>"},{"location":"reference/App/#handlerequest-req-response-res-response","title":"<code>handle(Request $req, Response $res): Response</code>","text":"<p>Processes a manually supplied request and returns a <code>Response</code>.</p>"},{"location":"reference/App/#parameters_7","title":"Parameters","text":"Name Type Description <code>$req</code> <code>Request</code> Request instance. <code>$res</code> <code>Response</code> Response instance."},{"location":"reference/App/#returns_1","title":"Returns","text":"<p><code>Response</code> \u2013 Populated response after route handling.</p>"},{"location":"reference/App/#private-methods","title":"Private Methods","text":""},{"location":"reference/App/#parseroutestring-route-string","title":"<code>parseRoute(string $route): string</code>","text":"<p>Converts a route string into a regex pattern.</p>"},{"location":"reference/App/#parameters_8","title":"Parameters","text":"Name Type Description <code>$route</code> <code>string</code> Route string (e.g., <code>/users/[id]</code>)."},{"location":"reference/App/#returns_2","title":"Returns","text":"<p><code>string</code> \u2013 Regex expression for matching the route.</p>"},{"location":"reference/App/#handlefallbackornotfoundrequest-req-response-res-void","title":"<code>handleFallbackOrNotFound(Request $req, Response $res): void</code>","text":"<p>Handles unmatched requests by serving assets or invoking the 404 handler.</p>"},{"location":"reference/App/#parameters_9","title":"Parameters","text":"Name Type Description <code>$req</code> <code>Request</code> The current request. <code>$res</code> <code>Response</code> The response object."},{"location":"reference/App/#getmethod-string","title":"<code>getMethod(): string</code>","text":"<p>Retrieves the HTTP method from the environment.</p>"},{"location":"reference/App/#returns_3","title":"Returns","text":"<p><code>string</code> \u2013 Uppercase HTTP method name.</p>"},{"location":"reference/App/#geturi-string","title":"<code>getUri(): string</code>","text":"<p>Retrieves and normalizes the request URI.</p>"},{"location":"reference/App/#returns_4","title":"Returns","text":"<p><code>string</code> \u2013 Normalized path (trailing slash removed except for <code>/</code>).</p>"},{"location":"reference/App/#applymiddlewarescallable-handler-array-middlewares-callable","title":"<code>applyMiddlewares(callable $handler, array $middlewares): callable</code>","text":"<p>Wraps a handler with a stack of middleware closures.</p>"},{"location":"reference/App/#parameters_10","title":"Parameters","text":"Name Type Description <code>$handler</code> <code>callable</code> The final route handler. <code>$middlewares</code> <code>array</code> List of middlewares to apply."},{"location":"reference/App/#returns_5","title":"Returns","text":"<p><code>callable</code> \u2013 Composed callable chain with middleware wrapping.</p>"},{"location":"reference/App/#behavior-summary","title":"Behavior Summary","text":"Feature Description Routing Regex-based pattern matching with dynamic parameters <code>[param]</code>. Middlewares Global and route-specific, with <code>$next</code> chaining. Exception Handling Per-class exception mapping and fallback. Asset Handling Delegated to <code>Assets</code> manager when provided. Logging Delegated to <code>LoggerInterface</code> (default <code>FileLogger</code>). Fallbacks Assets \u2192 Fallback \u2192 404 chain."},{"location":"reference/App/#see-also","title":"See Also","text":"<ul> <li><code>Request</code></li> <li><code>Response</code></li> <li><code>Assets</code></li> <li><code>Session</code></li> <li><code>Logging\\LoggerInterface</code></li> </ul>"},{"location":"reference/Assets/","title":"Class: <code>AdaiasMagdiel\\Erlenmeyer\\Assets</code>","text":"<p>Namespace: <code>AdaiasMagdiel\\Erlenmeyer</code> Defined in: <code>app/Assets.php</code></p>"},{"location":"reference/Assets/#overview","title":"Overview","text":"<p>The <code>Assets</code> class provides utilities to manage and serve static files (CSS, JS, images, fonts, etc.) through a configurable assets directory and route prefix. It handles file validation, MIME detection, caching headers, and HTTP 304 (Not Modified) responses.</p>"},{"location":"reference/Assets/#properties","title":"Properties","text":"Name Visibility Type Description <code>$assetsDirectory</code> private <code>string</code> Filesystem directory where static assets are stored. <code>$assetsRoute</code> private <code>string</code> Route prefix used to identify asset requests (e.g., <code>/assets</code>)."},{"location":"reference/Assets/#constructor","title":"Constructor","text":""},{"location":"reference/Assets/#__constructstring-assetsdirectory-public-string-assetsroute-assets","title":"<code>__construct(string $assetsDirectory = \"/public\", string $assetsRoute = \"/assets\")</code>","text":"<p>Creates a new <code>Assets</code> manager instance.</p>"},{"location":"reference/Assets/#parameters","title":"Parameters","text":"Name Type Description <code>$assetsDirectory</code> <code>string</code> Path to the directory containing asset files. <code>$assetsRoute</code> <code>string</code> Route prefix for asset requests (e.g., <code>/assets</code>)."},{"location":"reference/Assets/#throws","title":"Throws","text":"<ul> <li><code>InvalidArgumentException</code> \u2013 If the directory does not exist, is unreadable, or if the route is invalid.</li> </ul>"},{"location":"reference/Assets/#public-methods","title":"Public Methods","text":""},{"location":"reference/Assets/#getassetsdirectory-string","title":"<code>getAssetsDirectory(): string</code>","text":"<p>Returns the absolute directory path where assets are stored.</p>"},{"location":"reference/Assets/#returns","title":"Returns","text":"<p><code>string</code> \u2013 The asset storage directory path.</p>"},{"location":"reference/Assets/#getassetsroute-string","title":"<code>getAssetsRoute(): string</code>","text":"<p>Returns the route prefix for serving assets.</p>"},{"location":"reference/Assets/#returns_1","title":"Returns","text":"<p><code>string</code> \u2013 The route prefix (always prefixed with <code>/</code>).</p>"},{"location":"reference/Assets/#isassetrequestrequest-req-bool","title":"<code>isAssetRequest(Request $req): bool</code>","text":"<p>Determines whether the current request targets the asset route.</p>"},{"location":"reference/Assets/#parameters_1","title":"Parameters","text":"Name Type Description <code>$req</code> <code>Request</code> The current HTTP request instance."},{"location":"reference/Assets/#returns_2","title":"Returns","text":"<p><code>bool</code> \u2013 <code>true</code> if the request URI begins with the assets route prefix; otherwise <code>false</code>.</p>"},{"location":"reference/Assets/#serveassetrequest-req-bool","title":"<code>serveAsset(Request $req): bool</code>","text":"<p>Serves the requested asset file to the client.</p> <p>This method:</p> <ul> <li>Validates the request path.</li> <li>Checks for the file\u2019s existence.</li> <li>Ensures the requested path stays inside the configured assets directory.</li> <li>Sends the file with proper headers.</li> <li>Handles conditional requests (<code>If-None-Match</code>, <code>If-Modified-Since</code>).</li> </ul>"},{"location":"reference/Assets/#parameters_2","title":"Parameters","text":"Name Type Description <code>$req</code> <code>Request</code> The current HTTP request instance."},{"location":"reference/Assets/#returns_3","title":"Returns","text":"<p><code>bool</code> \u2013 <code>true</code> if the asset was found and served successfully, otherwise <code>false</code>.</p>"},{"location":"reference/Assets/#detectmimetypestring-filepath-string","title":"<code>detectMimeType(string $filePath): string</code>","text":"<p>Detects the appropriate MIME type for a given file based on its extension.</p>"},{"location":"reference/Assets/#parameters_3","title":"Parameters","text":"Name Type Description <code>$filePath</code> <code>string</code> Path to the file."},{"location":"reference/Assets/#returns_4","title":"Returns","text":"<p><code>string</code> \u2013 MIME type corresponding to the file extension, or <code>application/octet-stream</code> as fallback.</p>"},{"location":"reference/Assets/#private-methods","title":"Private Methods","text":""},{"location":"reference/Assets/#isvalidassetstring-path-bool","title":"<code>isValidAsset(string $path): bool</code>","text":"<p>Checks whether a given path points to a valid file.</p>"},{"location":"reference/Assets/#parameters_4","title":"Parameters","text":"Name Type Description <code>$path</code> <code>string</code> File path to validate."},{"location":"reference/Assets/#returns_5","title":"Returns","text":"<p><code>bool</code> \u2013 <code>true</code> if the path exists and is a regular file.</p>"},{"location":"reference/Assets/#sendfiletoclientstring-filepath-void","title":"<code>sendFileToClient(string $filePath): void</code>","text":"<p>Outputs the specified file to the HTTP response with appropriate headers.</p> <p>Headers include:</p> <ul> <li><code>Content-Type</code></li> <li><code>Content-Length</code></li> <li><code>Cache-Control</code></li> <li><code>ETag</code></li> <li><code>Last-Modified</code></li> </ul> <p>Supports browser caching via:</p> <ul> <li><code>If-None-Match</code> (ETag)</li> <li><code>If-Modified-Since</code></li> </ul> <p>If caching conditions are met, responds with 304 Not Modified.</p>"},{"location":"reference/Assets/#parameters_5","title":"Parameters","text":"Name Type Description <code>$filePath</code> <code>string</code> Full path to the file to send."},{"location":"reference/Assets/#behavior-summary","title":"Behavior Summary","text":"Feature Description Directory Validation Ensures asset directory exists and is readable. Route Detection Checks if requests match the configured asset route. Security Prevents directory traversal outside of asset root. MIME Detection Determines MIME type via file extension. HTTP Caching Supports ETag and Last-Modified headers for browser caching. Error Handling Returns 400, 404, or 500 when appropriate."},{"location":"reference/Assets/#see-also","title":"See Also","text":"<ul> <li><code>App</code></li> <li><code>Request</code></li> <li><code>Response</code></li> </ul>"},{"location":"reference/Request/","title":"Class: <code>AdaiasMagdiel\\Erlenmeyer\\Request</code>","text":"<p>Namespace: <code>AdaiasMagdiel\\Erlenmeyer</code> Defined in: <code>app/Request.php</code></p>"},{"location":"reference/Request/#overview","title":"Overview","text":"<p>The <code>Request</code> class represents an HTTP request and provides access to all request-related data, including headers, URI, method, query parameters, POST form data, JSON body, uploaded files, and client information such as IP address and User-Agent.</p> <p>This class is used internally by the <code>App</code> during route dispatching and can be used for manual request handling and testing.</p>"},{"location":"reference/Request/#properties","title":"Properties","text":"Name Visibility Type Description <code>$headers</code> private <code>array</code> HTTP request headers. <code>$method</code> private <code>string</code> HTTP method (e.g., <code>GET</code>, <code>POST</code>, etc.). <code>$uri</code> private <code>string</code> Normalized URI path (without query string). <code>$queryParams</code> private <code>array</code> Parsed query parameters. <code>$formData</code> private <code>array</code> POST form data. <code>$jsonData</code> private <code>?array</code> Lazily decoded JSON body data. <code>$jsonError</code> private <code>?string</code> JSON decoding error message (if any). <code>$rawBody</code> private <code>?string</code> Raw request body content. <code>$files</code> private <code>array</code> Uploaded file data (<code>$_FILES</code>). <code>$ip</code> private <code>?string</code> Client IP address. <code>$userAgent</code> private <code>?string</code> Client User-Agent string. <code>$server</code> private <code>array</code> Server environment data (<code>$_SERVER</code>)."},{"location":"reference/Request/#constructor","title":"Constructor","text":""},{"location":"reference/Request/#__constructarray-server-null-array-get-null-array-post-null-array-files-null-string-inputstream-phpinput-string-rawbody-null","title":"<code>__construct(?array $server = null, ?array $get = null, ?array $post = null, ?array $files = null, string $inputStream = 'php://input', ?string $rawBody = null)</code>","text":"<p>Creates a new <code>Request</code> instance, optionally using custom superglobals (useful for testing or CLI simulation).</p>"},{"location":"reference/Request/#parameters","title":"Parameters","text":"Name Type Description <code>$server</code> <code>?array</code> Server array (usually <code>$_SERVER</code>). <code>$get</code> <code>?array</code> Query string parameters (<code>$_GET</code>). <code>$post</code> <code>?array</code> POST data (<code>$_POST</code>). <code>$files</code> <code>?array</code> Uploaded files (<code>$_FILES</code>). <code>$inputStream</code> <code>string</code> Input stream path (default: <code>'php://input'</code>). <code>$rawBody</code> <code>?string</code> Optional raw body data override."},{"location":"reference/Request/#public-methods","title":"Public Methods","text":""},{"location":"reference/Request/#getheaderstring-name-string","title":"<code>getHeader(string $name): ?string</code>","text":"<p>Retrieves a header value by name (case-insensitive).</p> Parameter Type Description <code>$name</code> <code>string</code> Header name. <p>Returns: <code>?string</code> \u2013 Header value or <code>null</code> if not found.</p>"},{"location":"reference/Request/#getheaders-array","title":"<code>getHeaders(): array</code>","text":"<p>Returns all HTTP request headers.</p> <p>Returns: <code>array</code> \u2013 Associative array of all headers.</p>"},{"location":"reference/Request/#hasheaderstring-name-bool","title":"<code>hasHeader(string $name): bool</code>","text":"<p>Checks whether a specific header exists.</p> Parameter Type Description <code>$name</code> <code>string</code> Header name. <p>Returns: <code>bool</code> \u2013 <code>true</code> if header exists, otherwise <code>false</code>.</p>"},{"location":"reference/Request/#getmethod-string","title":"<code>getMethod(): string</code>","text":"<p>Returns the HTTP request method. Supports <code>_method</code> override via POST or <code>X-HTTP-Method-Override</code> header.</p> <p>Returns: <code>string</code> \u2013 HTTP method (e.g., <code>GET</code>, <code>POST</code>, <code>PUT</code>, etc.).</p>"},{"location":"reference/Request/#geturi-string","title":"<code>getUri(): string</code>","text":"<p>Returns the normalized request URI path (without query string).</p> <p>Returns: <code>string</code> \u2013 URI path.</p>"},{"location":"reference/Request/#getqueryparams-array","title":"<code>getQueryParams(): array</code>","text":"<p>Returns all query string parameters.</p> <p>Returns: <code>array</code> \u2013 Associative array of query parameters.</p>"},{"location":"reference/Request/#getqueryparamstring-key-mixed-default-null-mixed","title":"<code>getQueryParam(string $key, mixed $default = null): mixed</code>","text":"<p>Retrieves a specific query parameter.</p> Parameter Type Description <code>$key</code> <code>string</code> Parameter name. <code>$default</code> <code>mixed</code> Default value if not found. <p>Returns: <code>mixed</code> \u2013 Parameter value or default.</p>"},{"location":"reference/Request/#getformdata-array","title":"<code>getFormData(): array</code>","text":"<p>Returns all POST form data.</p> <p>Returns: <code>array</code> \u2013 Associative array of form fields.</p>"},{"location":"reference/Request/#getformdataparamstring-key-mixed-default-null-mixed","title":"<code>getFormDataParam(string $key, mixed $default = null): mixed</code>","text":"<p>Retrieves a specific POST form value.</p> Parameter Type Description <code>$key</code> <code>string</code> Form field key. <code>$default</code> <code>mixed</code> Default value if not found. <p>Returns: <code>mixed</code> \u2013 Form value or default.</p>"},{"location":"reference/Request/#getjsonbool-assoc-true-bool-ignorecontenttype-false-mixed","title":"<code>getJson(bool $assoc = true, bool $ignoreContentType = false): mixed</code>","text":"<p>Decodes and returns the JSON body of the request.</p>"},{"location":"reference/Request/#behavior","title":"Behavior","text":"<ul> <li>Automatically validates <code>Content-Type: application/json</code> unless <code>$ignoreContentType</code> is <code>true</code>.</li> <li>Returns decoded array or object depending on <code>$assoc</code>.</li> <li>Throws exception if decoding fails or content type is invalid.</li> </ul> Parameter Type Description <code>$assoc</code> <code>bool</code> Whether to return associative array (<code>true</code>) or object (<code>false</code>). <code>$ignoreContentType</code> <code>bool</code> Whether to ignore content-type validation. <p>Returns: <code>mixed</code> \u2013 Parsed JSON data (array or object). Throws: <code>RuntimeException</code> \u2013 On decoding errors or invalid <code>Content-Type</code>.</p>"},{"location":"reference/Request/#getjsonerror-string","title":"<code>getJsonError(): ?string</code>","text":"<p>Returns the last JSON decoding error message, if any.</p> <p>Returns: <code>?string</code> \u2013 Error message or <code>null</code>.</p>"},{"location":"reference/Request/#getrawbody-string","title":"<code>getRawBody(): ?string</code>","text":"<p>Returns the raw request body string.</p> <p>Returns: <code>?string</code> \u2013 Raw body or <code>null</code> if empty.</p>"},{"location":"reference/Request/#getfiles-array","title":"<code>getFiles(): array</code>","text":"<p>Returns all uploaded files.</p> <p>Returns: <code>array</code> \u2013 Same structure as PHP\u2019s <code>$_FILES</code>.</p>"},{"location":"reference/Request/#getfilestring-key-int-index-null-array","title":"<code>getFile(string $key, ?int $index = null): ?array</code>","text":"<p>Returns an uploaded file\u2019s metadata by key (and index for multiple uploads).</p> Parameter Type Description <code>$key</code> <code>string</code> File key. <code>$index</code> <code>?int</code> Optional index for multi-file uploads. <p>Returns: <code>?array</code> \u2013 File info (<code>name</code>, <code>type</code>, <code>tmp_name</code>, <code>error</code>, <code>size</code>) or <code>null</code>.</p>"},{"location":"reference/Request/#getip-string","title":"<code>getIp(): ?string</code>","text":"<p>Returns the detected client IP address.</p> <p>Returns: <code>?string</code> \u2013 IP address or <code>null</code>.</p>"},{"location":"reference/Request/#getuseragent-string","title":"<code>getUserAgent(): ?string</code>","text":"<p>Returns the client\u2019s User-Agent string.</p> <p>Returns: <code>?string</code> \u2013 User-Agent or <code>null</code>.</p>"},{"location":"reference/Request/#isajax-bool","title":"<code>isAjax(): bool</code>","text":"<p>Checks whether the request is an AJAX request (<code>X-Requested-With: XMLHttpRequest</code>).</p> <p>Returns: <code>bool</code> \u2013 <code>true</code> if AJAX, otherwise <code>false</code>.</p>"},{"location":"reference/Request/#issecure-bool","title":"<code>isSecure(): bool</code>","text":"<p>Checks whether the request was made via HTTPS.</p> <p>Returns: <code>bool</code> \u2013 <code>true</code> if secure (HTTPS), otherwise <code>false</code>.</p>"},{"location":"reference/Request/#behavior-summary","title":"Behavior Summary","text":"Feature Description Header Parsing Extracts headers from <code>$_SERVER</code> keys and normalizes names. Method Detection Supports overrides via <code>_method</code> field or <code>X-HTTP-Method-Override</code>. JSON Handling Safely decodes body JSON with detailed error reporting. Security Sanitizes query and form input to prevent injection. Client Info Detects IP, User-Agent, and proxy-forwarded addresses. Testing Support Constructor allows custom <code>$_SERVER</code>, <code>$_GET</code>, <code>$_POST</code>, and <code>$_FILES</code>."},{"location":"reference/Request/#see-also","title":"See Also","text":"<ul> <li><code>Response</code></li> <li><code>App</code></li> <li><code>Assets</code></li> </ul>"},{"location":"reference/Response/","title":"Class: <code>AdaiasMagdiel\\Erlenmeyer\\Response</code>","text":"<p>Namespace: <code>AdaiasMagdiel\\Erlenmeyer</code> Defined in: <code>app/Response.php</code></p>"},{"location":"reference/Response/#overview","title":"Overview","text":"<p>The <code>Response</code> class encapsulates HTTP response handling for Erlenmeyer applications. It provides structured methods for setting headers, status codes, and body content, including HTML, JSON, plain text, files, and templates.</p> <p>It also supports CORS configuration, redirects, cookies, and safe send state tracking.</p>"},{"location":"reference/Response/#properties","title":"Properties","text":"Name Visibility Type Description <code>$statusCode</code> private <code>int</code> HTTP status code (default: <code>200</code>). <code>$headers</code> private <code>array</code> Response headers. <code>$body</code> private <code>?string</code> Response body content. <code>$isSent</code> private <code>bool</code> Indicates if the response has already been sent. <code>$contentType</code> private <code>string</code> Current MIME type (default: <code>text/html</code>). <code>$functions</code> private static <code>array&lt;string, string&gt;</code> Map of native PHP functions used internally, replaceable for testing."},{"location":"reference/Response/#constructor","title":"Constructor","text":""},{"location":"reference/Response/#__constructint-statuscode-200-array-headers","title":"<code>__construct(int $statusCode = 200, array $headers = [])</code>","text":"<p>Initializes a new <code>Response</code> instance.</p>"},{"location":"reference/Response/#parameters","title":"Parameters","text":"Name Type Description <code>$statusCode</code> <code>int</code> Initial HTTP status code (default: <code>200</code>). <code>$headers</code> <code>array</code> Optional initial headers."},{"location":"reference/Response/#static-methods","title":"Static Methods","text":""},{"location":"reference/Response/#updatefunctionsarray-functions-void","title":"<code>updateFunctions(array $functions = []): void</code>","text":"<p>Overrides internal function mappings used by the class (e.g., <code>header()</code>).</p>"},{"location":"reference/Response/#parameters_1","title":"Parameters","text":"Name Type Description <code>$functions</code> <code>array</code> Associative array of function replacements. Useful for testing."},{"location":"reference/Response/#public-methods","title":"Public Methods","text":""},{"location":"reference/Response/#setstatuscodeint-code-self","title":"<code>setStatusCode(int $code): self</code>","text":"<p>Sets the HTTP status code.</p>"},{"location":"reference/Response/#parameters_2","title":"Parameters","text":"Name Type Description <code>$code</code> <code>int</code> HTTP status code (100\u2013599)."},{"location":"reference/Response/#returns","title":"Returns","text":"<p><code>self</code></p>"},{"location":"reference/Response/#throws","title":"Throws","text":"<p><code>InvalidArgumentException</code> \u2013 If the code is out of valid HTTP range.</p>"},{"location":"reference/Response/#getstatuscode-int","title":"<code>getStatusCode(): int</code>","text":"<p>Returns the current HTTP status code.</p> <p>Returns: <code>int</code></p>"},{"location":"reference/Response/#setheaderstring-name-string-value-self","title":"<code>setHeader(string $name, string $value): self</code>","text":"<p>Sets or replaces an HTTP header.</p>"},{"location":"reference/Response/#parameters_3","title":"Parameters","text":"Name Type Description <code>$name</code> <code>string</code> Header name. <code>$value</code> <code>string</code> Header value. <p>Returns: <code>self</code> Throws: <code>RuntimeException</code> \u2013 If headers were already sent.</p>"},{"location":"reference/Response/#removeheaderstring-name-self","title":"<code>removeHeader(string $name): self</code>","text":"<p>Removes a header from the response.</p>"},{"location":"reference/Response/#parameters_4","title":"Parameters","text":"Name Type Description <code>$name</code> <code>string</code> Header name. <p>Returns: <code>self</code> Throws: <code>RuntimeException</code> \u2013 If headers were already sent.</p>"},{"location":"reference/Response/#getheaders-array","title":"<code>getHeaders(): array</code>","text":"<p>Returns all response headers.</p> <p>Returns: <code>array</code></p>"},{"location":"reference/Response/#setcontenttypestring-contenttype-self","title":"<code>setContentType(string $contentType): self</code>","text":"<p>Sets the MIME type of the response and updates the <code>Content-Type</code> header.</p>"},{"location":"reference/Response/#parameters_5","title":"Parameters","text":"Name Type Description <code>$contentType</code> <code>string</code> MIME type (e.g., <code>text/html</code>, <code>application/json</code>). <p>Returns: <code>self</code></p>"},{"location":"reference/Response/#getcontenttype-string","title":"<code>getContentType(): string</code>","text":"<p>Returns the current content type.</p> <p>Returns: <code>string</code></p>"},{"location":"reference/Response/#setbodystring-body-self","title":"<code>setBody(string $body): self</code>","text":"<p>Sets the raw response body.</p>"},{"location":"reference/Response/#parameters_6","title":"Parameters","text":"Name Type Description <code>$body</code> <code>string</code> Response body. <p>Returns: <code>self</code></p>"},{"location":"reference/Response/#getbody-string","title":"<code>getBody(): ?string</code>","text":"<p>Returns the current response body.</p> <p>Returns: <code>?string</code></p>"},{"location":"reference/Response/#withhtmlstring-html-self","title":"<code>withHtml(string $html): self</code>","text":"<p>Sets an HTML response body and content type.</p>"},{"location":"reference/Response/#parameters_7","title":"Parameters","text":"Name Type Description <code>$html</code> <code>string</code> HTML markup. <p>Returns: <code>self</code></p>"},{"location":"reference/Response/#withtemplatestring-templatepath-array-data-self","title":"<code>withTemplate(string $templatePath, array $data = []): self</code>","text":"<p>Renders a PHP template file as the response body.</p>"},{"location":"reference/Response/#parameters_8","title":"Parameters","text":"Name Type Description <code>$templatePath</code> <code>string</code> Path to the template file. <code>$data</code> <code>array</code> Variables passed to the template scope. <p>Returns: <code>self</code> Throws: <code>RuntimeException</code> \u2013 If the template file cannot be found.</p>"},{"location":"reference/Response/#withjsonmixed-data-int-options-json_pretty_print-self","title":"<code>withJson(mixed $data, int $options = JSON_PRETTY_PRINT): self</code>","text":"<p>Sets a JSON response body and content type.</p>"},{"location":"reference/Response/#parameters_9","title":"Parameters","text":"Name Type Description <code>$data</code> <code>mixed</code> Data to encode as JSON. <code>$options</code> <code>int</code> Options for <code>json_encode()</code> (default: <code>JSON_PRETTY_PRINT</code>). <p>Returns: <code>self</code> Throws: <code>RuntimeException</code> \u2013 If JSON encoding fails.</p>"},{"location":"reference/Response/#withtextstring-text-self","title":"<code>withText(string $text): self</code>","text":"<p>Sets a plain text response.</p>"},{"location":"reference/Response/#parameters_10","title":"Parameters","text":"Name Type Description <code>$text</code> <code>string</code> Plain text content. <p>Returns: <code>self</code></p>"},{"location":"reference/Response/#redirectstring-url-int-statuscode-302-self","title":"<code>redirect(string $url, int $statusCode = 302): self</code>","text":"<p>Performs an HTTP redirect by setting <code>Location</code> and clearing the body.</p>"},{"location":"reference/Response/#parameters_11","title":"Parameters","text":"Name Type Description <code>$url</code> <code>string</code> Target URL. <code>$statusCode</code> <code>int</code> Redirect status code (3xx). Default: <code>302</code>. <p>Returns: <code>self</code> Throws: <code>InvalidArgumentException</code> \u2013 If status code is not in the 3xx range.</p>"},{"location":"reference/Response/#withcookiestring-name-string-value-int-expire-0-string-path-string-domain-bool-secure-false-bool-httponly-true-self","title":"<code>withCookie(string $name, string $value, int $expire = 0, string $path = '/', string $domain = '', bool $secure = false, bool $httpOnly = true): self</code>","text":"<p>Adds a <code>Set-Cookie</code> header to the response.</p>"},{"location":"reference/Response/#parameters_12","title":"Parameters","text":"Name Type Description <code>$name</code> <code>string</code> Cookie name. <code>$value</code> <code>string</code> Cookie value. <code>$expire</code> <code>int</code> Expiration timestamp (0 for session cookie). <code>$path</code> <code>string</code> Path for which the cookie is valid. <code>$domain</code> <code>string</code> Cookie domain. <code>$secure</code> <code>bool</code> Send only over HTTPS if <code>true</code>. <code>$httpOnly</code> <code>bool</code> Prevent JavaScript access if <code>true</code>. <p>Returns: <code>self</code></p>"},{"location":"reference/Response/#send-void","title":"<code>send(): void</code>","text":"<p>Sends the HTTP response to the client, including headers and body.</p> <p>Throws:</p> <ul> <li><code>RuntimeException</code> \u2013 If headers are already sent.</li> <li><code>RuntimeException</code> \u2013 If the response has already been sent.</li> </ul>"},{"location":"reference/Response/#issent-bool","title":"<code>isSent(): bool</code>","text":"<p>Returns whether the response has already been sent.</p> <p>Returns: <code>bool</code></p>"},{"location":"reference/Response/#clear-self","title":"<code>clear(): self</code>","text":"<p>Clears all headers and body while keeping the current status code.</p> <p>Returns: <code>self</code> Throws: <code>RuntimeException</code> \u2013 If response has already been sent.</p>"},{"location":"reference/Response/#witherrorint-statuscode-string-message-callable-logger-null-self","title":"<code>withError(int $statusCode, string $message = '', ?callable $logger = null): self</code>","text":"<p>Creates an error response with optional logging.</p>"},{"location":"reference/Response/#parameters_13","title":"Parameters","text":"Name Type Description <code>$statusCode</code> <code>int</code> HTTP status code. <code>$message</code> <code>string</code> Optional error message. <code>$logger</code> <code>?callable</code> Optional logger function <code>(int $code, string $message)</code>. <p>Returns: <code>self</code></p>"},{"location":"reference/Response/#withfilestring-filepath-self","title":"<code>withFile(string $filePath): self</code>","text":"<p>Sends a file as a downloadable attachment.</p>"},{"location":"reference/Response/#parameters_14","title":"Parameters","text":"Name Type Description <code>$filePath</code> <code>string</code> Absolute file path. <p>Returns: <code>self</code> Throws: <code>RuntimeException</code> \u2013 If the file is not readable.</p>"},{"location":"reference/Response/#setcorsarray-options-self","title":"<code>setCORS(array $options): self</code>","text":"<p>Configures Cross-Origin Resource Sharing (CORS) headers.</p>"},{"location":"reference/Response/#options","title":"Options","text":"Key Type Description <code>origin</code> <code>string \\| string[]</code> Allowed origin(s). <code>methods</code> <code>string \\| string[]</code> Allowed HTTP methods. <code>headers</code> <code>string \\| string[]</code> Allowed request headers. <code>credentials</code> <code>bool</code> Whether to allow credentials. <code>max_age</code> <code>int</code> Cache duration (in seconds). <p>Returns: <code>self</code> Throws: <code>RuntimeException</code> \u2013 If the response has already been sent.</p>"},{"location":"reference/Response/#behavior-summary","title":"Behavior Summary","text":"Feature Description Status Handling Validates HTTP status codes and enforces range 100\u2013599. Header Safety Prevents modification after the response is sent. Content Helpers Supports HTML, JSON, text, files, and templates. Cookies Simplified cookie management via headers. CORS Easily configure cross-origin headers. Redirects Sets standard 3xx redirects with URL validation. Send Protection Ensures responses are sent exactly once. Testing Supports overriding core PHP I/O functions for unit testing."},{"location":"reference/Response/#see-also","title":"See Also","text":"<ul> <li><code>Request</code></li> <li><code>App</code></li> <li><code>Assets</code></li> </ul>"},{"location":"reference/Session/","title":"Class: <code>AdaiasMagdiel\\Erlenmeyer\\Session</code>","text":"<p>Namespace: <code>AdaiasMagdiel\\Erlenmeyer</code> Defined in: <code>app/Session.php</code></p>"},{"location":"reference/Session/#overview","title":"Overview","text":"<p>The <code>Session</code> class provides static helper methods for managing PHP session data and flash messages in a structured and predictable way.</p> <p>It abstracts the native <code>$_SESSION</code> superglobal, automatically ensures the session is started when needed, and supports temporary flash values that persist for a single request.</p>"},{"location":"reference/Session/#behavior-summary","title":"Behavior Summary","text":"Feature Description Automatic Initialization Automatically starts the session when needed. Key/Value Storage Provides <code>get</code>, <code>set</code>, <code>has</code>, and <code>remove</code> for standard session keys. Flash Messages Supports temporary values that are cleared after retrieval. Validation Prevents usage of empty session keys. Stateless Access Static interface \u2014 no instantiation required."},{"location":"reference/Session/#private-methods","title":"Private Methods","text":""},{"location":"reference/Session/#ensuresessionstarted-void","title":"<code>ensureSessionStarted(): void</code>","text":"<p>Ensures that a PHP session is active. If no session is started, it calls <code>session_start()</code>.</p> <p>Returns: <code>void</code></p>"},{"location":"reference/Session/#public-static-methods","title":"Public Static Methods","text":""},{"location":"reference/Session/#getstring-key-mixed-default-null-mixed","title":"<code>get(string $key, mixed $default = null): mixed</code>","text":"<p>Retrieves a session value by key.</p> Parameter Type Description <code>$key</code> <code>string</code> The session key. <code>$default</code> <code>mixed</code> Value to return if the key does not exist. <p>Returns: <code>mixed</code> \u2013 The stored value or the default.</p>"},{"location":"reference/Session/#setstring-key-mixed-value-void","title":"<code>set(string $key, mixed $value): void</code>","text":"<p>Stores a value in the session.</p> Parameter Type Description <code>$key</code> <code>string</code> Session key. <code>$value</code> <code>mixed</code> Value to store. <p>Returns: <code>void</code> Throws: <code>InvalidArgumentException</code> \u2013 If the key is empty.</p>"},{"location":"reference/Session/#hasstring-key-bool","title":"<code>has(string $key): bool</code>","text":"<p>Checks whether a session key exists.</p> Parameter Type Description <code>$key</code> <code>string</code> Session key to check. <p>Returns: <code>bool</code> \u2013 <code>true</code> if the key exists, otherwise <code>false</code>.</p>"},{"location":"reference/Session/#removestring-key-void","title":"<code>remove(string $key): void</code>","text":"<p>Removes a key (and its value) from the session.</p> Parameter Type Description <code>$key</code> <code>string</code> Key to remove. <p>Returns: <code>void</code></p>"},{"location":"reference/Session/#flashstring-key-mixed-value-void","title":"<code>flash(string $key, mixed $value): void</code>","text":"<p>Sets a flash message available for the next request only. Flash data is automatically deleted after retrieval.</p> Parameter Type Description <code>$key</code> <code>string</code> Flash message key. <code>$value</code> <code>mixed</code> Flash message value. <p>Returns: <code>void</code> Throws: <code>InvalidArgumentException</code> \u2013 If the key is empty.</p>"},{"location":"reference/Session/#getflashstring-key-mixed-default-null-mixed","title":"<code>getFlash(string $key, mixed $default = null): mixed</code>","text":"<p>Retrieves and removes a flash message from the session. Once retrieved, the flash value is deleted immediately.</p> Parameter Type Description <code>$key</code> <code>string</code> Flash key. <code>$default</code> <code>mixed</code> Default value if not found. <p>Returns: <code>mixed</code> \u2013 The flash message value or default.</p>"},{"location":"reference/Session/#hasflashstring-key-bool","title":"<code>hasFlash(string $key): bool</code>","text":"<p>Checks whether a flash message exists.</p> Parameter Type Description <code>$key</code> <code>string</code> Flash key to check. <p>Returns: <code>bool</code> \u2013 <code>true</code> if the flash message exists, otherwise <code>false</code>.</p>"},{"location":"reference/Session/#usage-notes","title":"Usage Notes","text":"<ul> <li>Sessions are started lazily \u2014 the first call to any method triggers <code>session_start()</code> if necessary.</li> <li>Flash messages are stored in the <code>$_SESSION['flash']</code> array internally.</li> <li>After retrieving a flash message, it is immediately removed from the session.</li> </ul>"},{"location":"reference/Session/#see-also","title":"See Also","text":"<ul> <li><code>App</code></li> <li><code>Request</code></li> <li><code>Response</code></li> </ul>"},{"location":"reference/Logging/ConsoleLogger/","title":"Class: <code>AdaiasMagdiel\\Erlenmeyer\\Logging\\ConsoleLogger</code>","text":"<p>Namespace: <code>AdaiasMagdiel\\Erlenmeyer\\Logging</code> Implements: <code>LoggerInterface</code> Defined in: <code>app/Logging/ConsoleLogger.php</code></p>"},{"location":"reference/Logging/ConsoleLogger/#overview","title":"Overview","text":"<p>The <code>ConsoleLogger</code> writes formatted log entries to the PHP error log (stderr). It supports all standard log levels and allows excluding specific levels from output.</p> <p>It also provides detailed exception logging, including stack traces and optional request context information.</p>"},{"location":"reference/Logging/ConsoleLogger/#properties","title":"Properties","text":"Name Visibility Type Description <code>excludedLogLevels</code> public <code>LogLevel[]</code> List of log levels to ignore."},{"location":"reference/Logging/ConsoleLogger/#constants","title":"Constants","text":"Name Value Description <code>TIMESTAMP_FORMAT</code> <code>'Y-m-d H:i:s'</code> Date/time format used in all log entries."},{"location":"reference/Logging/ConsoleLogger/#constructor","title":"Constructor","text":""},{"location":"reference/Logging/ConsoleLogger/#__constructarray-excludedloglevels","title":"<code>__construct(array $excludedLogLevels = [])</code>","text":"<p>Creates a new <code>ConsoleLogger</code> instance.</p> Parameter Type Description <code>$excludedLogLevels</code> <code>LogLevel[]</code> Array of levels to exclude from logging. <p>Throws: <code>InvalidArgumentException</code> \u2013 If any element is not a <code>LogLevel</code> instance.</p>"},{"location":"reference/Logging/ConsoleLogger/#methods","title":"Methods","text":""},{"location":"reference/Logging/ConsoleLogger/#logloglevel-level-loglevelinfo-string-message-void","title":"<code>log(LogLevel $level = LogLevel::INFO, string $message = ''): void</code>","text":"<p>Logs a message to the PHP error log.</p> Parameter Type Description <code>$level</code> <code>LogLevel</code> Log severity level. <code>$message</code> <code>string</code> Message to log (must not be empty). <p>Returns: <code>void</code> Throws: <code>InvalidArgumentException</code> \u2013 If the message is empty.</p>"},{"location":"reference/Logging/ConsoleLogger/#logexceptionexception-exception-request-request-null-void","title":"<code>logException(Exception $exception, ?Request $request = null): void</code>","text":"<p>Logs an exception with contextual information.</p> Parameter Type Description <code>$exception</code> <code>Exception</code> Exception to log. <code>$request</code> <code>?Request</code> Optional request for additional context. <p>Returns: <code>void</code></p>"},{"location":"reference/Logging/ConsoleLogger/#behavior-summary","title":"Behavior Summary","text":"Feature Description Destination Writes logs to PHP error log (<code>error_log()</code>) or stderr fallback. Timestamping All entries are timestamped using <code>Y-m-d H:i:s</code>. Exclusion List Supports filtering specific log levels. Exception Logging Includes file, line, message, stack trace, and request data. Security Escapes messages to prevent log injection."},{"location":"reference/Logging/ConsoleLogger/#see-also","title":"See Also","text":"<ul> <li><code>FileLogger</code></li> <li><code>LoggerInterface</code></li> <li><code>LogLevel</code></li> </ul>"},{"location":"reference/Logging/FileLogger/","title":"Class: <code>AdaiasMagdiel\\Erlenmeyer\\Logging\\FileLogger</code>","text":"<p>Namespace: <code>AdaiasMagdiel\\Erlenmeyer\\Logging</code> Implements: <code>LoggerInterface</code> Defined in: <code>app/Logging/FileLogger.php</code></p>"},{"location":"reference/Logging/FileLogger/#overview","title":"Overview","text":"<p>The <code>FileLogger</code> writes structured log entries to disk. It supports log rotation, retention limits, and contextual exception logging. Each log entry includes a timestamp, level, and message.</p>"},{"location":"reference/Logging/FileLogger/#constants","title":"Constants","text":"Name Value Description <code>MAX_LOG_SIZE</code> <code>3 * 1024 * 1024</code> Maximum log file size before rotation (3 MB). <code>MAX_LOG_FILES</code> <code>5</code> Maximum number of rotated log files retained."},{"location":"reference/Logging/FileLogger/#properties","title":"Properties","text":"Name Visibility Type Description <code>$logDir</code> private <code>?string</code> Directory where log files are stored (or <code>null</code> if disabled). <code>$logFile</code> private <code>string</code> Full path to the active log file."},{"location":"reference/Logging/FileLogger/#constructor","title":"Constructor","text":""},{"location":"reference/Logging/FileLogger/#__constructstring-logdir","title":"<code>__construct(string $logDir = '')</code>","text":"<p>Creates a new <code>FileLogger</code> instance.</p> Parameter Type Description <code>$logDir</code> <code>string</code> Directory for storing logs. Empty disables logging. <p>Behavior:</p> <ul> <li>Automatically creates the directory if missing.</li> <li>Defaults to writing logs to <code>info.log</code> in the provided directory.</li> </ul>"},{"location":"reference/Logging/FileLogger/#methods","title":"Methods","text":""},{"location":"reference/Logging/FileLogger/#logloglevel-level-loglevelinfo-string-message-void","title":"<code>log(LogLevel $level = LogLevel::INFO, string $message = ''): void</code>","text":"<p>Writes a formatted log entry to the active file.</p> Parameter Type Description <code>$level</code> <code>LogLevel</code> Log severity level. <code>$message</code> <code>string</code> Message content. <p>Returns: <code>void</code> Notes:</p> <ul> <li>Automatically rotates when file size exceeds <code>MAX_LOG_SIZE</code>.</li> <li>Skips logging if <code>$logDir</code> is <code>null</code>.</li> </ul>"},{"location":"reference/Logging/FileLogger/#logexceptionexception-exception-request-request-null-void","title":"<code>logException(Exception $exception, ?Request $request = null): void</code>","text":"<p>Logs detailed exception information.</p> Parameter Type Description <code>$exception</code> <code>Exception</code> Exception to log. <code>$request</code> <code>?Request</code> Optional HTTP request context. <p>Returns: <code>void</code></p>"},{"location":"reference/Logging/FileLogger/#rotatelogfile-void-private","title":"<code>rotateLogFile(): void</code> (private)","text":"<p>Handles file rotation when size exceeds <code>MAX_LOG_SIZE</code>.</p> <p>Behavior:</p> <ul> <li>Renames old logs (e.g., <code>info.log.1 \u2192 info.log.2</code>).</li> <li>Keeps up to <code>MAX_LOG_FILES</code> rotated versions.</li> <li>Writes <code>\"Log file rotated.\"</code> to the new file.</li> </ul>"},{"location":"reference/Logging/FileLogger/#behavior-summary","title":"Behavior Summary","text":"Feature Description File Rotation Automatically renames logs when exceeding 3 MB. Retention Keeps up to 5 historical log files. Formatting Standard <code>[timestamp] [LEVEL] message</code> format. Contextual Exceptions Includes stack trace and optional request data. Silent Disable Logging disabled if <code>$logDir</code> is empty or invalid."},{"location":"reference/Logging/FileLogger/#see-also","title":"See Also","text":"<ul> <li><code>ConsoleLogger</code></li> <li><code>LoggerInterface</code></li> <li><code>LogLevel</code></li> </ul>"},{"location":"reference/Logging/LogLevel/","title":"Enum: <code>AdaiasMagdiel\\Erlenmeyer\\Logging\\LogLevel</code>","text":"<p>Namespace: <code>AdaiasMagdiel\\Erlenmeyer\\Logging</code> Defined in: <code>app/Logging/LogLevel.php</code></p>"},{"location":"reference/Logging/LogLevel/#overview","title":"Overview","text":"<p>Represents the severity of a log message. Each log level indicates the urgency or criticality of a logged event.</p>"},{"location":"reference/Logging/LogLevel/#enum-cases","title":"Enum Cases","text":"Case Value Description <code>DEBUG</code> <code>'DEBUG'</code> Low-level system information for debugging purposes. <code>INFO</code> <code>'INFO'</code> General operational messages that highlight progress. <code>WARNING</code> <code>'WARNING'</code> Indications of potential issues or non-critical errors. <code>ERROR</code> <code>'ERROR'</code> Runtime errors or unexpected conditions requiring attention. <code>CRITICAL</code> <code>'CRITICAL'</code> Serious failures that require immediate investigation."},{"location":"reference/Logging/LogLevel/#usage-example","title":"Usage Example","text":"<pre><code>use AdaiasMagdiel\\Erlenmeyer\\Logging\\LogLevel;\n\n$level = LogLevel::ERROR;\necho $level-&gt;value; // \"ERROR\"\n</code></pre>"},{"location":"reference/Logging/LoggerInterface/","title":"Interface: <code>AdaiasMagdiel\\Erlenmeyer\\Logging\\LoggerInterface</code>","text":"<p>Namespace: <code>AdaiasMagdiel\\Erlenmeyer\\Logging</code> Defined in: <code>app/Logging/LoggerInterface.php</code></p>"},{"location":"reference/Logging/LoggerInterface/#overview","title":"Overview","text":"<p>Defines the contract for logging messages and exceptions in Erlenmeyer.</p> <p>Implementations of this interface provide consistent logging behavior, allowing the application to write logs to various destinations (console, file, etc.) using standardized severity levels.</p>"},{"location":"reference/Logging/LoggerInterface/#methods","title":"Methods","text":""},{"location":"reference/Logging/LoggerInterface/#logloglevel-level-string-message-void","title":"<code>log(LogLevel $level, string $message): void</code>","text":"<p>Writes a log entry with the specified severity level.</p> Parameter Type Description <code>$level</code> <code>LogLevel</code> Severity level of the log message. <code>$message</code> <code>string</code> Message text to log. <p>Returns: <code>void</code></p>"},{"location":"reference/Logging/LoggerInterface/#logexceptionexception-e-request-request-null-void","title":"<code>logException(Exception $e, ?Request $request = null): void</code>","text":"<p>Logs an exception, optionally including HTTP request context.</p> Parameter Type Description <code>$e</code> <code>Exception</code> Exception instance to log. <code>$request</code> <code>?Request</code> Optional request providing context (method, URI, etc.). <p>Returns: <code>void</code></p>"},{"location":"reference/Logging/LoggerInterface/#implementations","title":"Implementations","text":"<ul> <li><code>ConsoleLogger</code></li> <li><code>FileLogger</code></li> </ul>"},{"location":"reference/Testing/ErlenClient/","title":"Class: <code>AdaiasMagdiel\\Erlenmeyer\\Testing\\ErlenClient</code>","text":"<p>Namespace: <code>AdaiasMagdiel\\Erlenmeyer\\Testing</code> Defined in: <code>app/Testing/ErlenClient.php</code></p>"},{"location":"reference/Testing/ErlenClient/#overview","title":"Overview","text":"<p>The <code>ErlenClient</code> class provides a lightweight testing client for simulating HTTP requests directly within an Erlenmeyer application \u2014 without starting a web server.</p> <p>It enables integration testing by emulating full HTTP request cycles and supports headers, query strings, JSON bodies, form parameters, and file uploads.</p>"},{"location":"reference/Testing/ErlenClient/#properties","title":"Properties","text":"Name Visibility Type Description <code>$app</code> private <code>App</code> The <code>App</code> instance under test. <code>$defaultHeaders</code> private <code>array</code> Default headers automatically included in all requests."},{"location":"reference/Testing/ErlenClient/#constructor","title":"Constructor","text":""},{"location":"reference/Testing/ErlenClient/#__constructapp-app","title":"<code>__construct(App $app)</code>","text":"<p>Creates a new testing client bound to a specific <code>App</code> instance.</p>"},{"location":"reference/Testing/ErlenClient/#parameters","title":"Parameters","text":"Name Type Description <code>$app</code> <code>App</code> The application instance that will handle simulated requests."},{"location":"reference/Testing/ErlenClient/#methods","title":"Methods","text":""},{"location":"reference/Testing/ErlenClient/#withheadersarray-headers-self","title":"<code>withHeaders(array $headers): self</code>","text":"<p>Adds default headers that will be included in all subsequent requests.</p>"},{"location":"reference/Testing/ErlenClient/#parameters_1","title":"Parameters","text":"Name Type Description <code>$headers</code> <code>array</code> Associative array of header names and values. <p>Returns: <code>self</code></p>"},{"location":"reference/Testing/ErlenClient/#resetheaders-self","title":"<code>resetHeaders(): self</code>","text":"<p>Clears all default headers previously set via <code>withHeaders()</code>.</p> <p>Returns: <code>self</code></p>"},{"location":"reference/Testing/ErlenClient/#http-method-shortcuts","title":"HTTP Method Shortcuts","text":"<p>Each of the following methods simulates a specific HTTP verb and delegates to <code>request()</code> internally.</p> Method Signature Description <code>get()</code> <code>get(string $uri, array $options = []): Response</code> Sends a GET request. <code>post()</code> <code>post(string $uri, array $options = []): Response</code> Sends a POST request. <code>put()</code> <code>put(string $uri, array $options = []): Response</code> Sends a PUT request. <code>patch()</code> <code>patch(string $uri, array $options = []): Response</code> Sends a PATCH request. <code>delete()</code> <code>delete(string $uri, array $options = []): Response</code> Sends a DELETE request. <code>head()</code> <code>head(string $uri, array $options = []): Response</code> Sends a HEAD request. <code>options()</code> <code>options(string $uri, array $options = []): Response</code> Sends an OPTIONS request. <p>All methods return a <code>Response</code> instance.</p>"},{"location":"reference/Testing/ErlenClient/#requeststring-method-string-uri-array-options-response","title":"<code>request(string $method, string $uri, array $options = []): Response</code>","text":"<p>Executes an HTTP request against the application. This method is the core of the testing client and powers all HTTP verb shortcuts.</p>"},{"location":"reference/Testing/ErlenClient/#parameters_2","title":"Parameters","text":"Name Type Description <code>$method</code> <code>string</code> HTTP method (GET, POST, PUT, etc.). <code>$uri</code> <code>string</code> Request URI (absolute or relative). <code>$options</code> <code>array</code> Optional configuration array:"},{"location":"reference/Testing/ErlenClient/#options","title":"Options","text":"Key Type Description <code>headers</code> <code>array</code> Custom HTTP headers. <code>query</code> <code>array</code> Query string parameters. <code>json</code> <code>array</code> Data to encode as JSON (<code>Content-Type</code> automatically set). <code>form_params</code> <code>array</code> Form data (encoded as <code>application/x-www-form-urlencoded</code>). <code>files</code> <code>array</code> Simulated uploaded files (mirrors <code>$_FILES</code> structure). <code>body</code> <code>string</code> Raw body content."},{"location":"reference/Testing/ErlenClient/#returns","title":"Returns","text":"<p><code>Response</code> \u2014 The response object returned by the application.</p>"},{"location":"reference/Testing/ErlenClient/#normalizeuristring-uri-string-private","title":"<code>normalizeUri(string $uri): string</code> (private)","text":"<p>Normalizes a URI path in the same way as <code>App</code>. Removes trailing slashes except for <code>/</code> and preserves query strings and fragments.</p>"},{"location":"reference/Testing/ErlenClient/#parameters_3","title":"Parameters","text":"Name Type Description <code>$uri</code> <code>string</code> URI to normalize. <p>Returns: <code>string</code> \u2013 Normalized URI.</p>"},{"location":"reference/Testing/ErlenClient/#behavior-summary","title":"Behavior Summary","text":"Feature Description Server Emulation Simulates <code>$_SERVER</code>, <code>$_GET</code>, <code>$_POST</code>, and <code>$_FILES</code> for the request. Header Management Merges global and per-request headers automatically. Payload Support Accepts JSON, form, and raw body payloads. Query Handling Builds and attaches query strings dynamically. Response Integration Returns a real <code>Response</code> object from the <code>App</code>. No Server Required Requests are handled entirely in memory \u2014 no sockets or HTTP server needed."},{"location":"reference/Testing/ErlenClient/#see-also","title":"See Also","text":"<ul> <li><code>App</code></li> <li><code>Request</code></li> <li><code>Response</code></li> </ul>"}]}